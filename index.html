<!doctype html>
<html lang="ko" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vehlog</title>

    <link
      rel="stylesheet"
      as="style"
      crossorigin
      href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css"
    />

    <!-- Tailwind CSS -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4.1.18"></script>
    <style type="text/tailwindcss">
      @theme {
        --color-border: hsl(var(--border));
        --color-input: hsl(var(--input));
        --color-ring: hsl(var(--ring));
        --color-background: hsl(var(--background));
        --color-foreground: hsl(var(--foreground));

        --color-primary: hsl(var(--primary));
        --color-primary-foreground: hsl(var(--primary-foreground));
        --color-secondary: hsl(var(--secondary));
        --color-secondary-foreground: hsl(var(--secondary-foreground));
        --color-muted: hsl(var(--muted));
        --color-muted-foreground: hsl(var(--muted-foreground));
        --color-accent: hsl(var(--accent));
        --color-accent-foreground: hsl(var(--accent-foreground));
        --color-popover: hsl(var(--popover));
        --color-popover-foreground: hsl(var(--popover-foreground));
        --color-destructive: hsl(var(--destructive));
        --color-destructive-foreground: hsl(var(--destructive-foreground));

        --color-dark-950: #09090b;
        --color-dark-900: #18181b;
        --color-dark-800: #27272a;
        --color-dark-700: #3f3f46;

        --color-brand: #6366f1;
        --color-brand-hover: #4f46e5;

        --radius-lg: var(--radius);
        --radius-md: calc(var(--radius) - 2px);
        --radius-sm: calc(var(--radius) - 4px);

        --font-sans:
          'Pretendard', '-apple-system', 'BlinkMacSystemFont', 'system-ui', 'Roboto', 'sans-serif';
      }
    </style>
    <style>
      :root {
        --background: 240 10% 3.9%;
        --foreground: 0 0% 98%;
        --card: 240 10% 3.9%;
        --card-foreground: 0 0% 98%;
        --popover: 240 10% 3.9%;
        --popover-foreground: 0 0% 98%;
        --primary: 0 0% 98%;
        --primary-foreground: 240 5.9% 10%;
        --secondary: 240 3.7% 15.9%;
        --secondary-foreground: 0 0% 98%;
        --muted: 240 3.7% 15.9%;
        --muted-foreground: 240 5% 64.9%;
        --accent: 240 3.7% 15.9%;
        --accent-foreground: 0 0% 98%;
        --destructive: 0 62.8% 30.6%;
        --destructive-foreground: 0 0% 98%;
        --border: 240 3.7% 15.9%;
        --input: 240 3.7% 15.9%;
        --ring: 240 4.9% 83.9%;
        --radius: 0.5rem;
      }

      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: #3f3f46;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #52525b;
      }

      input[type='number']::-webkit-inner-spin-button,
      input[type='number']::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      [x-cloak] {
        display: none !important;
      }

      ::view-transition-old(vt-header),
      ::view-transition-new(vt-header),
      ::view-transition-old(vt-route-panel),
      ::view-transition-new(vt-route-panel),
      ::view-transition-old(vt-tab-panel),
      ::view-transition-new(vt-tab-panel) {
        animation-duration: 260ms;
        animation-timing-function: cubic-bezier(0.22, 1, 0.36, 1);
        pointer-events: none;
      }

      :root {
        view-transition-name: none;
      }

      ::view-transition {
        pointer-events: none;
      }

      @media (prefers-reduced-motion: reduce) {
        ::view-transition-old(*),
        ::view-transition-new(*) {
          animation: none;
        }
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/dexie@4.2.1/dist/dexie.min.js"></script>
    <script src="https://unpkg.com/clxdb@0.5.0/dist/clxdb.umd.cjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.15.8/dist/cdn.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.563.0/dist/umd/lucide.min.js"></script>
  </head>
  <body
    class="bg-background text-foreground selection:bg-brand min-h-screen overflow-x-hidden font-sans
      antialiased selection:text-white"
    x-data="app()"
    x-cloak
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="512"
      height="512"
      fill="none"
      viewBox="0 0 512 512"
      style="display: none"
    >
      <defs>
        <symbol id="vehlog_icon" viewBox="0 0 512 512">
          <rect width="512" height="512" fill="#6366f1" rx="100" />
          <g fill="#fff" filter="url(#filter0_d_2_2)">
            <path
              d="M144 402a16 16 0 0 0 16-16v-16h-16c-5.61 0-11-.96-16-2.73V386a16 16 0 0 0 16 16M368 402a16 16 0 0 0 16-16v-18.73a48 48 0 0 1-16 2.73h-16v16a16 16 0 0 0 16 16M123.31 182.69a16 16 0 0 0-22.62 22.62l14.38 14.38a48 48 0 0 1 11.27-6.34c3.85-1.52 7.2-4.28 8.73-8.12l3.09-7.7zM411.31 182.69a16 16 0 0 0-22.62 0l-14.93 14.92 3.1 7.64c1.54 3.83 4.89 6.56 8.72 8.07a48 48 0 0 1 11.35 6.38l14.38-14.39a16 16 0 0 0 0-22.62"
            />
          </g>
          <g fill="#fff" filter="url(#filter1_f_2_2)">
            <path
              d="M144 338a16 16 0 0 0-16 16v13.27c5 1.77 10.39 2.73 16 2.73h16v-16a16 16 0 0 0-16-16M368 338a16 16 0 0 0-16 16v16h16c5.61 0 11-.96 16-2.73V354a16 16 0 0 0-16-16M155.31 237.31a16 16 0 0 0 0-22.62l-17.15-17.16-3.09 7.7c-1.53 3.84-4.88 6.6-8.73 8.12a48 48 0 0 0-11.27 6.34l17.62 17.62a16 16 0 0 0 22.62 0M356.69 237.31a16 16 0 0 0 22.62 0l17.62-17.62a48 48 0 0 0-11.35-6.37c-3.83-1.51-7.18-4.24-8.72-8.07l-3.1-7.64-17.07 17.07a16 16 0 0 0 0 22.63"
            />
          </g>
          <g filter="url(#filter2_i_2_2)">
            <path
              fill="#fff"
              fill-opacity=".15"
              d="M416 322a48 48 0 0 1-48 48H144a48 48 0 0 1-48-48v-64a48 48 0 0 1 30.34-44.65c3.85-1.52 7.2-4.28 8.73-8.12l18.03-45.06A48 48 0 0 1 198.48 130h116.01a48 48 0 0 1 44.37 30.87l18 44.38c1.54 3.83 4.89 6.56 8.72 8.07A48 48 0 0 1 416 258z"
            />
          </g>
          <path
            stroke="url(#paint0_linear_2_2)"
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width=".8"
            fill="none"
            d="M416 322a48 48 0 0 1-48 48H144a48 48 0 0 1-48-48v-64a48 48 0 0 1 30.34-44.65c3.85-1.52 7.2-4.28 8.73-8.12l18.03-45.06A48 48 0 0 1 198.48 130h116.01a48 48 0 0 1 44.37 30.87l18 44.38c1.54 3.83 4.89 6.56 8.72 8.07A48 48 0 0 1 416 258z"
          />
          <g fill="#fff" filter="url(#filter3_d_2_2)">
            <path
              d="M152 290a16 16 0 0 1 16-16h19.2a16 16 0 0 1 0 32H168a16 16 0 0 1-16-16M308.8 290a16 16 0 0 1 16-16H344a16 16 0 0 1 0 32h-19.2a16 16 0 0 1-16-16"
            />
          </g>
        </symbol>
        <filter
          id="filter0_d_2_2"
          width="400"
          height="304"
          x="56"
          y="138"
          color-interpolation-filters="sRGB"
          filterUnits="userSpaceOnUse"
        >
          <feFlood flood-opacity="0" result="BackgroundImageFix" />
          <feColorMatrix
            in="SourceAlpha"
            result="hardAlpha"
            values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
          />
          <feOffset />
          <feGaussianBlur stdDeviation="20" />
          <feComposite in2="hardAlpha" operator="out" />
          <feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.5 0" />
          <feBlend in2="BackgroundImageFix" result="effect1_dropShadow_2_2" />
          <feBlend in="SourceGraphic" in2="effect1_dropShadow_2_2" result="shape" />
        </filter>
        <filter
          id="filter1_f_2_2"
          width="361.86"
          height="252.47"
          x="75.07"
          y="157.53"
          color-interpolation-filters="sRGB"
          filterUnits="userSpaceOnUse"
        >
          <feFlood flood-opacity="0" result="BackgroundImageFix" />
          <feBlend in="SourceGraphic" in2="BackgroundImageFix" result="shape" />
          <feGaussianBlur result="effect1_foregroundBlur_2_2" stdDeviation="20" />
        </filter>
        <filter
          id="filter2_i_2_2"
          width="320.8"
          height="240.81"
          x="95.6"
          y="129.59"
          color-interpolation-filters="sRGB"
          filterUnits="userSpaceOnUse"
        >
          <feFlood flood-opacity="0" result="BackgroundImageFix" />
          <feBlend in="SourceGraphic" in2="BackgroundImageFix" result="shape" />
          <feColorMatrix
            in="SourceAlpha"
            result="hardAlpha"
            values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
          />
          <feOffset />
          <feGaussianBlur stdDeviation="12" />
          <feComposite in2="hardAlpha" k2="-1" k3="1" operator="arithmetic" />
          <feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.2 0" />
          <feBlend in2="shape" result="effect1_innerShadow_2_2" />
        </filter>
        <filter
          id="filter3_d_2_2"
          width="288"
          height="112"
          x="112"
          y="234"
          color-interpolation-filters="sRGB"
          filterUnits="userSpaceOnUse"
        >
          <feFlood flood-opacity="0" result="BackgroundImageFix" />
          <feColorMatrix
            in="SourceAlpha"
            result="hardAlpha"
            values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
          />
          <feOffset />
          <feGaussianBlur stdDeviation="20" />
          <feComposite in2="hardAlpha" operator="out" />
          <feColorMatrix values="0 0 0 0 0.388235 0 0 0 0 0.4 0 0 0 0 0.945098 0 0 0 0.5 0" />
          <feBlend in2="BackgroundImageFix" result="effect1_dropShadow_2_2" />
          <feBlend in="SourceGraphic" in2="effect1_dropShadow_2_2" result="shape" />
        </filter>
        <linearGradient
          id="paint0_linear_2_2"
          x1="117.6"
          x2="432.4"
          y1="70.8"
          y2="470.4"
          gradientUnits="userSpaceOnUse"
        >
          <stop offset=".18" stop-color="#c9cbff" stop-opacity="0" />
          <stop offset=".47" stop-color="#c9cbff" />
          <stop offset=".68" stop-color="#c9cbff" stop-opacity="0" />
        </linearGradient>
      </defs>
    </svg>

    <div class="pointer-events-none fixed inset-0 z-0">
      <div
        class="bg-brand/10 absolute top-[-10%] left-[-10%] h-[40%] w-[40%] rounded-full
          blur-[120px]"
      ></div>
      <div
        class="absolute right-[-10%] bottom-[-10%] h-[40%] w-[40%] rounded-full bg-purple-900/10
          blur-[120px]"
      ></div>
    </div>

    <!-- Main Container -->
    <div class="relative z-10 mx-auto flex h-screen max-w-5xl flex-col px-4 py-6">
      <!-- Header -->
      <header
        x-show="router.current !== 'onboarding'"
        class="border-border mb-6 flex h-16 shrink-0 items-center justify-between border-b pb-4
          transition-all duration-300"
      >
        <div class="flex items-center gap-3">
          <template x-if="router.current === 'car-list'">
            <div class="flex items-center gap-3" style="view-transition-name: vt-header">
              <svg viewBox="0 0 512 512" class="h-9 w-9">
                <use href="#vehlog_icon" x="0" y="0" />
              </svg>
              <h1 class="text-xl font-bold tracking-tight">Vehlog</h1>
            </div>
          </template>
          <template x-if="router.current === 'car-detail'">
            <div class="flex items-center gap-3" style="view-transition-name: vt-header">
              <button
                @click="goToCarList()"
                class="hover:bg-accent hover:border-border flex h-9 w-9 items-center justify-center
                  rounded-md border border-transparent transition-colors"
              >
                <i x-lucide="arrow-left" class="h-5 w-5"></i>
              </button>
              <div>
                <h2 class="text-lg leading-none font-bold" x-text="activeCar?.number"></h2>
                <p class="text-muted-foreground mt-1 text-xs" x-text="activeCar?.model"></p>
              </div>
            </div>
          </template>
        </div>

        <div class="flex gap-2">
          <div x-data="({ open: false })" class="relative">
            <button
              @click="open = !open"
              class="hover:bg-accent text-muted-foreground hover:text-foreground flex h-9 w-9
                items-center justify-center rounded-md transition-colors"
            >
              <i x-lucide="settings" class="h-5 w-5"></i>
            </button>
            <div
              x-show="open"
              @click.outside="open = false"
              x-transition:enter="transition ease-out duration-100"
              x-transition:enter-start="opacity-0 scale-95"
              x-transition:enter-end="opacity-100 scale-100"
              class="bg-popover border-border absolute right-0 z-50 mt-2 w-48 rounded-lg border py-1
                shadow-xl"
            >
              <button
                @click="exportDB(); open = false"
                class="hover:bg-accent flex w-full items-center gap-2 px-4 py-2 text-left text-sm"
              >
                <i x-lucide="download" class="h-4 w-4"></i> 내보내기 (JSON)
              </button>
              <button
                @click="triggerImport(); open = false"
                class="hover:bg-accent flex w-full items-center gap-2 px-4 py-2 text-left text-sm"
              >
                <i x-lucide="upload" class="h-4 w-4"></i> 가져오기
              </button>
              <div class="bg-border my-1 h-px"></div>
              <button
                @click="closeDatabase(); open = false"
                class="hover:bg-accent flex w-full items-center gap-2 px-4 py-2 text-left text-sm
                  text-red-400"
              >
                <i x-lucide="log-out" class="h-4 w-4"></i> 데이터베이스 닫기
              </button>
            </div>
          </div>
        </div>
      </header>

      <!-- View: Onboarding -->
      <template x-if="router.current === 'onboarding'">
        <main
          style="view-transition-name: vt-route-panel"
          class="flex flex-1 flex-col items-center justify-center pb-20 text-center"
        >
          <div class="relative mb-8">
            <svg class="h-20 w-20" viewBox="0 0 512 512">
              <use href="#vehlog_icon" x="0" y="0" />
            </svg>
          </div>
          <h1 class="mb-4 text-4xl font-bold tracking-tight md:text-5xl">차계부 관리의 시작</h1>
          <p class="text-muted-foreground mb-12 max-w-md text-lg">
            안전하게 내 차의 모든 기록을 관리하세요.<br />데이터는 브라우저에 저장되거나 클라우드와
            연동됩니다.
          </p>
          <div class="w-full max-w-xl">
            <button
              @click="startDatabase()"
              :disabled="isStartingDb"
              class="group border-border bg-card hover:bg-accent relative w-full overflow-hidden
                rounded-xl border p-6 text-left transition-all duration-300
                disabled:pointer-events-none disabled:opacity-70"
            >
              <div
                class="bg-secondary mb-4 flex h-10 w-10 items-center justify-center rounded-full
                  transition-transform group-hover:scale-110"
              >
                <i x-lucide="database" class="h-5 w-5"></i>
              </div>
              <h3
                class="mb-1 text-lg font-semibold"
                x-text="isStartingDb ? '여는 중...' : '시작하기'"
              ></h3>
              <p class="text-muted-foreground text-sm">
                데이터베이스 연결을 시작하고 저장소 선택 및 잠금 해제를 진행합니다.
              </p>
            </button>
          </div>
        </main>
      </template>

      <!-- View: Car Selection (List) -->
      <template x-if="router.current === 'car-list'">
        <main style="view-transition-name: vt-route-panel" class="flex-1">
          <!-- (Car List Content preserved) -->
          <div class="mb-6 flex items-end justify-between">
            <div>
              <h2 class="text-2xl font-bold">나의 차량</h2>
              <p class="text-muted-foreground mt-1 text-sm">관리할 차량을 선택하거나 추가하세요.</p>
            </div>
            <button
              @click="openModal('add-car')"
              class="focus-visible:ring-ring bg-primary text-primary-foreground hover:bg-primary/90
                inline-flex h-10 items-center justify-center rounded-md px-4 py-2 text-sm
                font-medium shadow-xs transition-colors focus-visible:ring-1
                focus-visible:outline-none"
            >
              <i x-lucide="plus" class="mr-2 h-4 w-4"></i> 차량 추가
            </button>
          </div>
          <div class="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
            <template x-for="car in db?.cars" :key="car.id">
              <div
                @click="selectCar(car.id)"
                class="group bg-card border-border hover:border-brand/50 hover:bg-accent/50 relative
                  cursor-pointer rounded-xl border p-5 transition-all duration-200"
              >
                <div class="relative z-10 flex h-full flex-col justify-between">
                  <div>
                    <div class="mb-2 flex items-start justify-between">
                      <span
                        class="border-border text-foreground inline-flex items-center rounded-md
                          border px-2.5 py-0.5 text-xs font-semibold transition-colors"
                        x-text="car.fuelType"
                      >
                      </span>
                      <i
                        x-lucide="chevron-right"
                        class="text-muted-foreground group-hover:text-foreground h-4 w-4
                          transition-colors"
                      >
                      </i>
                    </div>
                    <h3 class="text-xl font-bold tracking-tight" x-text="car.number"></h3>
                    <p
                      class="text-muted-foreground text-sm"
                      x-text="car.maker + ' ' + car.model"
                    ></p>
                  </div>
                  <div
                    class="border-border text-muted-foreground mt-6 flex justify-between border-t
                      pt-4 text-xs"
                  >
                    <span x-text="car.year + '년식'"></span>
                    <span x-text="formatDistance(car.totalDistance)"></span>
                  </div>
                </div>
              </div>
            </template>
            <template x-if="!db?.cars.length">
              <div
                class="text-muted-foreground border-border bg-card/50 col-span-full flex flex-col
                  items-center justify-center rounded-xl border border-dashed py-20"
              >
                <i x-lucide="car" class="mb-4 h-12 w-12 opacity-50"></i>
                <p class="text-lg font-medium">등록된 차량이 없습니다.</p>
              </div>
            </template>
          </div>
        </main>
      </template>

      <!-- View: Car Detail -->
      <template x-if="router.current === 'car-detail'">
        <main
          class="flex h-full flex-1 flex-col overflow-hidden"
          style="view-transition-name: vt-route-panel"
        >
          <!-- Tabs -->
          <div class="border-border mb-6 flex w-full items-center border-b">
            <template x-for="tab in ['info', 'refuel', 'maintenance', 'etc']">
              <button
                @click="switchTab(tab)"
                class="relative px-4 py-2.5 text-sm font-medium transition-colors"
                :class="detail.tab === tab ? 'text-brand' : 'text-muted-foreground hover:text-foreground'"
              >
                <span
                  x-text="({ info: '정보', refuel: '주유', maintenance: '정비', etc: '기타' })[tab]"
                >
                </span>
                <div
                  :style="({ opacity: +(detail.tab === tab) })"
                  class="bg-brand absolute right-0 bottom-0 left-0 h-0.5 transition-opacity"
                ></div>
              </button>
            </template>
          </div>

          <!-- Content Area -->
          <div
            class="relative flex flex-1 flex-col overflow-hidden"
            style="view-transition-name: vt-tab-panel"
          >
            <!-- Tab: Info -->
            <div
              x-show="detail.tab === 'info'"
              class="animate-in fade-in zoom-in-95 flex-1 overflow-y-auto pb-20 duration-200"
            >
              <div class="bg-card border-border rounded-xl border p-6">
                <!-- Info Header & Form (Preserved) -->
                <div class="mb-6 flex items-center justify-between">
                  <h3 class="flex items-center gap-2 text-lg font-bold">
                    <i x-lucide="info" class="text-brand h-4 w-4"></i> 기본 정보
                  </h3>
                  <button
                    @click="toggleEditInfo()"
                    class="border-border hover:bg-accent flex items-center gap-1.5 rounded-md border
                      px-3 py-1.5 text-xs transition-colors"
                    :class="detail.isEditing ? 'text-red-400 border-red-900/50 bg-red-900/10' : 'text-muted-foreground'"
                  >
                    <i x-lucide-dynamic="detail.isEditing ? 'x' : 'pencil'" class="h-3 w-3"></i>
                    <span x-text="detail.isEditing ? '취소' : '편집'"></span>
                  </button>
                </div>
                <!-- Info View -->
                <div
                  x-show="!detail.isEditing"
                  class="grid grid-cols-1 gap-x-8 gap-y-6 md:grid-cols-2"
                >
                  <template
                    x-for="label in ['차량번호', '제조사', '차종', '등급', '연식', '연료', '배기량', '누적 주행거리']"
                  >
                    <div class="space-y-1">
                      <p
                        class="text-muted-foreground text-xs font-medium tracking-wider uppercase"
                        x-text="label"
                      ></p>
                      <p class="text-lg font-medium" x-text="getCarInfoValue(label)"></p>
                    </div>
                  </template>
                </div>

                <!-- Info Edit Form -->
                <template x-if="detail.carInfoEditBuffer">
                  <form
                    x-show="detail.isEditing"
                    @submit.prevent="saveCarInfo"
                    class="grid grid-cols-1 gap-4 md:grid-cols-2"
                  >
                    <div class="space-y-1.5">
                      <label class="text-muted-foreground text-xs font-medium">차량번호</label>
                      <input
                        type="text"
                        x-model="detail.carInfoEditBuffer.number"
                        class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md
                          border bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                          focus-visible:ring-1 focus-visible:outline-none"
                      />
                    </div>
                    <div class="space-y-1.5">
                      <label class="text-muted-foreground text-xs font-medium">제조사</label>
                      <input
                        type="text"
                        x-model="detail.carInfoEditBuffer.maker"
                        class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md
                          border bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                          focus-visible:ring-1 focus-visible:outline-none"
                      />
                    </div>
                    <div class="space-y-1.5">
                      <label class="text-muted-foreground text-xs font-medium">차종</label>
                      <input
                        type="text"
                        x-model="detail.carInfoEditBuffer.model"
                        class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md
                          border bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                          focus-visible:ring-1 focus-visible:outline-none"
                      />
                    </div>
                    <div class="space-y-1.5">
                      <label class="text-muted-foreground text-xs font-medium">등급</label>
                      <input
                        type="text"
                        x-model="detail.carInfoEditBuffer.grade"
                        class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md
                          border bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                          focus-visible:ring-1 focus-visible:outline-none"
                      />
                    </div>
                    <div class="space-y-1.5">
                      <label class="text-muted-foreground text-xs font-medium">연식</label>
                      <input
                        type="number"
                        x-model="detail.carInfoEditBuffer.year"
                        class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md
                          border bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                          focus-visible:ring-1 focus-visible:outline-none"
                      />
                    </div>
                    <div class="space-y-1.5">
                      <label class="text-muted-foreground text-xs font-medium">연료</label>
                      <select
                        x-model="detail.carInfoEditBuffer.fuelType"
                        class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md
                          border bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                          focus-visible:ring-1 focus-visible:outline-none"
                      >
                        <option>휘발유</option>
                        <option>경유</option>
                        <option>LPG</option>
                        <option>전기</option>
                        <option>하이브리드</option>
                      </select>
                    </div>
                    <div class="col-span-full flex justify-end pt-4">
                      <button
                        type="submit"
                        class="bg-primary text-primary-foreground hover:bg-primary/90 inline-flex
                          h-9 items-center justify-center rounded-md px-4 text-sm font-medium shadow
                          transition-colors"
                      >
                        저장
                      </button>
                    </div>
                  </form>
                </template>
              </div>
            </div>

            <!-- Tab: Refuel / Maintenance / Etc -->
            <div
              x-show="['refuel', 'maintenance', 'etc'].includes(detail.tab)"
              class="animate-in fade-in zoom-in-95 flex flex-1 flex-col overflow-hidden
                duration-200"
            >
              <!-- Dashboard (Refuel Only) -->
              <div x-show="detail.tab === 'refuel'" class="mb-6 flex gap-4">
                <!-- Card 1: Cost Comparison -->
                <div
                  class="bg-card border-border flex h-32 max-w-[300px] flex-1 flex-col
                    justify-between rounded-xl border p-4"
                >
                  <span class="text-muted-foreground text-xs font-medium">이번 달 주유비</span>
                  <div class="mt-2 flex flex-col justify-start gap-1">
                    <span
                      class="text-4xl font-bold tracking-tight"
                      x-text="formatNumber(getMonthlyRefuelCost().current)"
                    ></span>
                    <div
                      class="mt-2 flex items-center gap-1 text-xs font-medium"
                      :class="getMonthlyRefuelCost().diff > 0 ? 'text-red-400' : 'text-green-400'"
                    >
                      <span class="text-muted-foreground">지난달 대비</span>
                      <span x-text="formatNumber(getMonthlyRefuelCost().diff)"></span>
                      <span x-text="getMonthlyRefuelCost().diff > 0 ? '\u25b2' : '\u25bc'"></span>
                    </div>
                  </div>
                </div>

                <!-- Card 2: Efficiency Graph -->
                <div
                  x-data="chart()"
                  x-init="initChart()"
                  @mousemove="handleMouseMove"
                  @mouseleave="hover = false"
                  class="bg-card border-border group relative flex h-32 max-w-[400px] flex-1
                    flex-col overflow-hidden rounded-xl border p-4 select-none"
                >
                  <div class="pointer-events-none relative z-20 mb-4">
                    <span class="text-muted-foreground text-xs font-medium"
                      >최근 연비 추이 (km/L)</span
                    >
                    <div x-show="points.length > 0" class="absolute top-0 right-0 text-right">
                      <div
                        class="text-foreground text-2xl font-bold tabular-nums"
                        x-text="points.at(hover ? hoverIndex : -1)?.val"
                      ></div>
                      <div
                        class="text-muted-foreground text-[10px]"
                        x-text="points.at(hover ? hoverIndex : -1)?.date"
                      ></div>
                    </div>
                  </div>

                  <div class="relative z-10 min-h-0 w-full flex-1">
                    <template x-if="points.length > 1">
                      <svg
                        class="h-full w-full overflow-visible"
                        viewBox="0 0 100 100"
                        preserveAspectRatio="none"
                      >
                        <defs>
                          <linearGradient id="chartGradient" x1="0" x2="0" y1="0" y2="1">
                            <stop offset="0%" stop-color="white" stop-opacity="0.2" />
                            <stop offset="100%" stop-color="white" stop-opacity="0" />
                          </linearGradient>
                        </defs>

                        <!-- Gradient Area -->
                        <path :d="getAreaPath()" fill="url(#chartGradient)" stroke="none" />

                        <!-- Line -->
                        <path
                          :d="getPath()"
                          fill="none"
                          stroke="white"
                          stroke-width="1.5"
                          stroke-linecap="round"
                          stroke-linejoin="round"
                          vector-effect="non-scaling-stroke"
                        />

                        <!-- Hover Line & Dot (Custom Scaling) -->
                        <g x-show="hover && hoverIndex > -1">
                          <line
                            :x1="points[hoverIndex]?.x ?? 0"
                            y1="0"
                            :x2="points[hoverIndex]?.x ?? 0"
                            y2="100"
                            stroke="white"
                            stroke-width="1"
                            stroke-dasharray="2 2"
                            opacity="0.5"
                            vector-effect="non-scaling-stroke"
                          />
                        </g>
                      </svg>
                    </template>
                    <template x-if="points.length <= 1">
                      <div
                        class="text-muted-foreground border-border flex h-full w-full items-center
                          justify-center rounded-lg border border-dashed text-xs"
                      >
                        표시할 데이터가 부족합니다.
                      </div>
                    </template>
                  </div>
                </div>
              </div>

              <!-- Maintenance Timers -->
              <div x-show="detail.tab === 'maintenance'" class="mb-5 space-y-3">
                <div class="flex items-center justify-between px-3">
                  <div>
                    <h4 class="text-sm font-semibold">해야 할 정비</h4>
                    <p class="text-muted-foreground text-xs">정비 시점을 타이머로 관리하세요.</p>
                  </div>
                  <button
                    @click="openModal('add-maintenance-timer')"
                    class="border-border hover:bg-accent inline-flex h-8 items-center justify-center
                      rounded-md border px-3 text-xs font-medium transition-colors"
                  >
                    <i x-lucide="plus" class="mr-1.5 h-3.5 w-3.5"></i>
                    타이머 추가
                  </button>
                </div>

                <template x-if="maintenanceTimerCards.length > 0">
                  <div class="-mx-1 flex gap-3 overflow-x-auto px-1 pb-1">
                    <template x-for="timerCard in maintenanceTimerCards" :key="timerCard.id">
                      <div
                        class="bg-card border-border max-w-[320px] min-w-[280px] shrink-0 rounded-xl
                          border p-4"
                      >
                        <div class="flex items-start justify-between gap-2">
                          <h5
                            class="max-w-[170px] truncate text-sm font-semibold"
                            x-text="timerCard.title"
                          ></h5>
                          <span
                            class="inline-flex items-center rounded-full border px-2 py-0.5
                              text-[10px] font-semibold"
                            :class="timerCard.repeat
                              ? 'border-transparent bg-brand/15 text-brand'
                              : 'border-border text-muted-foreground'"
                            x-text="timerCard.repeat ? '반복' : '1회'"
                          >
                          </span>
                        </div>

                        <p
                          class="text-muted-foreground mt-1 text-[11px]"
                          x-text="timerCard.conditionLabel"
                        ></p>
                        <p
                          class="mt-1 text-sm font-semibold tabular-nums"
                          :class="timerCard.isOverdue ? 'text-red-400' : 'text-foreground'"
                          x-text="timerCard.remainingLabel"
                        ></p>

                        <div class="bg-secondary mt-3 h-2 overflow-hidden rounded-full">
                          <div
                            class="h-full rounded-full transition-all duration-300"
                            :class="timerCard.isOverdue ? 'bg-red-500' : 'bg-brand'"
                            :style="`width: ${timerCard.progressPercent}%`"
                          ></div>
                        </div>

                        <div class="mt-3 flex gap-2">
                          <button
                            @click="completeMaintenanceTimer(timerCard.id)"
                            class="bg-primary text-primary-foreground hover:bg-primary/90
                              inline-flex h-8 flex-1 items-center justify-center rounded-md px-2
                              text-xs font-medium transition-colors"
                          >
                            완료
                          </button>
                          <button
                            @click="deleteMaintenanceTimer(timerCard.id)"
                            class="border-border text-muted-foreground hover:bg-accent
                              hover:text-destructive inline-flex h-8 flex-1 items-center
                              justify-center rounded-md border px-2 text-xs font-medium
                              transition-colors"
                          >
                            삭제
                          </button>
                        </div>
                      </div>
                    </template>
                  </div>
                </template>

                <template x-if="maintenanceTimerCards.length === 0">
                  <div
                    class="text-muted-foreground border-border bg-card/40 flex items-center
                      justify-between rounded-lg border border-dashed px-4 py-3 text-xs"
                  >
                    <span>등록된 정비 타이머가 없습니다.</span>
                    <button
                      @click="openModal('add-maintenance-timer')"
                      class="hover:text-foreground inline-flex items-center gap-1 font-medium"
                    >
                      <i x-lucide="plus" class="h-3.5 w-3.5"></i>
                      추가
                    </button>
                  </div>
                </template>
              </div>

              <!-- Filter Bar -->
              <div class="mb-4 flex flex-col items-stretch gap-2 sm:flex-row sm:items-center">
                <div class="relative flex-1">
                  <i
                    x-lucide="search"
                    class="text-muted-foreground absolute top-1/2 left-2.5 h-4 w-4 -translate-y-1/2"
                  >
                  </i>
                  <input
                    type="text"
                    x-model="filters.search"
                    @input.debounce.300ms="handleFiltersChanged()"
                    placeholder="검색..."
                    class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                      bg-transparent py-1 pr-3 pl-9 text-sm shadow-xs transition-colors
                      focus-visible:ring-1 focus-visible:outline-none"
                  />
                </div>
                <div class="flex items-center gap-2">
                  <div
                    class="bg-card border-input flex h-9 items-center gap-1 rounded-md border px-2"
                  >
                    <input
                      type="date"
                      x-model="filters.dateStart"
                      @change="handleFiltersChanged()"
                      class="text-foreground h-full w-[90px] border-none bg-transparent p-0 text-xs
                        outline-none focus:ring-0"
                    />
                    <span class="text-muted-foreground">~</span>
                    <input
                      type="date"
                      x-model="filters.dateEnd"
                      @change="handleFiltersChanged()"
                      class="text-foreground h-full w-[90px] border-none bg-transparent p-0 text-xs
                        outline-none focus:ring-0"
                    />
                  </div>
                  <div x-show="detail.tab === 'maintenance'" class="relative">
                    <select
                      x-model="filters.type"
                      @change="handleFiltersChanged()"
                      class="border-input focus-visible:ring-ring flex h-9 w-[80px] rounded-md
                        border bg-transparent px-2 py-1 text-xs shadow-xs transition-colors
                        focus-visible:ring-1 focus-visible:outline-none"
                    >
                      <option value="all">전체</option>
                      <option value="maintenance">정비</option>
                      <option value="inspection">점검</option>
                    </select>
                  </div>
                </div>
                <button
                  @click="openModal('add-record')"
                  class="focus-visible:ring-ring bg-primary text-primary-foreground
                    hover:bg-primary/90 inline-flex h-9 items-center justify-center rounded-md px-4
                    text-sm font-medium whitespace-nowrap shadow transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                >
                  <i x-lucide="plus" class="mr-2 h-4 w-4"></i>
                  <span x-text="getAddButtonText()"></span>
                </button>
              </div>

              <!-- List Content -->
              <div class="flex-1 space-y-2 overflow-y-auto pr-1 pb-20">
                <template x-for="(record, index) in filteredRecords" :key="record.id">
                  <div
                    class="group bg-card border-border hover:bg-accent/50 relative rounded-lg border
                      p-4 transition-colors"
                  >
                    <!-- Delete Button -->
                    <button
                      @click.stop="deleteRecord(record.id)"
                      class="text-muted-foreground bg-popover hover:text-destructive hover:bg-accent
                        absolute top-2 right-2 z-10 rounded-md p-1.5 opacity-0 transition-all
                        group-hover:opacity-100"
                    >
                      <i x-lucide="trash-2" class="h-4 w-4"></i>
                    </button>

                    <div class="mb-2 flex items-start justify-between">
                      <div class="flex items-center gap-2">
                        <span class="text-muted-foreground font-mono text-xs" x-text="record.date">
                        </span>
                        <span
                          class="inline-flex items-center rounded-full border px-2 py-0.5
                            text-[10px] font-semibold transition-colors"
                          :class="({
                            'border-transparent bg-brand/10 text-brand': ['full', 'maintenance'].includes(record.subType),
                            'border-transparent bg-orange-500/10 text-orange-400': ['partial', 'inspection'].includes(
                              record.subType
                            ),
                            'border-transparent bg-secondary text-secondary-foreground': !record.subType,
                          })"
                          x-text="getSubTypeLabel(record)"
                        >
                        </span>
                      </div>
                      <span
                        class="font-bold tabular-nums"
                        x-text="formatNumber(record.amount) + '원'"
                      >
                      </span>
                    </div>

                    <div class="flex items-end justify-between text-sm">
                      <div class="flex flex-col gap-1">
                        <span
                          class="max-w-[200px] truncate text-[16px] font-bold"
                          x-text="getRecordLabel(record)"
                        >
                        </span>
                        <div class="flex items-center gap-0.5">
                          <div
                            class="text-muted-foreground text-xs tabular-nums"
                            x-text="formatDistance(record.odometer)"
                          ></div>
                          <span class="text-border mx-1">|</span>
                          <span class="text-muted-foreground flex items-center gap-1 text-xs">
                            <i x-lucide="map-pin" class="h-3 w-3"></i>
                            <span x-text="record.place || '장소 미지정'"></span>
                          </span>
                        </div>
                      </div>
                      <div class="flex flex-col items-end gap-0.5 text-right">
                        <template x-if="detail.tab === 'refuel' && record.volume">
                          <div class="flex flex-col items-end">
                            <div class="text-muted-foreground text-[10px]">
                              <span x-text="record.volume + 'L'"></span>
                              <span class="text-border mx-1">|</span>
                              <span x-text="formatNumber(record.unitPrice) + '원/L'"></span>
                            </div>
                            <template x-if="getEfficiency(record, index)">
                              <div
                                class="mt-0.5 flex items-center gap-1 rounded bg-green-900/10 px-1.5
                                  py-0.5 text-[10px] font-medium text-green-500"
                              >
                                <span
                                  x-text="'+' + formatDistance(getEfficiency(record, index)?.dist ?? 0)"
                                >
                                </span>
                                <span class="text-border">|</span>
                                <span x-text="(getEfficiency(record, index)?.eff ?? 0) + ' km/L'">
                                </span>
                              </div>
                            </template>
                          </div>
                        </template>
                      </div>
                    </div>
                  </div>
                </template>
                <template x-if="recordPage.loading">
                  <div class="py-12 text-center">
                    <p class="text-muted-foreground text-sm">불러오는 중...</p>
                  </div>
                </template>
                <template x-if="!recordPage.loading && filteredRecords.length === 0">
                  <div class="py-12 text-center">
                    <div
                      class="bg-secondary mb-4 inline-flex h-12 w-12 items-center justify-center
                        rounded-full"
                    >
                      <i x-lucide="inbox" class="text-muted-foreground h-6 w-6"></i>
                    </div>
                    <p class="text-muted-foreground text-sm">내역이 없습니다.</p>
                  </div>
                </template>
              </div>
              <div
                x-show="filteredRecords.length > 0 || recordPage.hasPrev || recordPage.hasNext"
                class="border-border mt-3 flex items-center justify-between border-t pt-3"
              >
                <button
                  @click="goToPrevRecordsPage()"
                  :disabled="!recordPage.hasPrev || recordPage.loading"
                  class="border-border hover:bg-accent inline-flex h-8 items-center justify-center
                    rounded-md border px-3 text-xs transition-colors disabled:pointer-events-none
                    disabled:opacity-40"
                >
                  이전
                </button>
                <span class="text-muted-foreground text-xs" x-text="getRecordsPageLabel()"></span>
                <button
                  @click="goToNextRecordsPage()"
                  :disabled="!recordPage.hasNext || recordPage.loading"
                  class="border-border hover:bg-accent inline-flex h-8 items-center justify-center
                    rounded-md border px-3 text-xs transition-colors disabled:pointer-events-none
                    disabled:opacity-40"
                >
                  다음
                </button>
              </div>
            </div>
          </div>
        </main>
      </template>
    </div>

    <input
      type="file"
      id="fileInput"
      accept=".json"
      class="hidden"
      @change="handleFileImport($event)"
    />

    <!-- Modals -->
    <div
      x-show="modal.active"
      class="fixed inset-0 z-50 flex items-center justify-center p-4 sm:p-0"
      style="display: none"
    >
      <div
        x-show="modal.active"
        x-transition.opacity
        @click="closeModal()"
        class="bg-background/80 absolute inset-0 backdrop-blur-sm"
      ></div>
      <div
        x-show="modal.active"
        x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0 scale-95 translate-y-4"
        x-transition:enter-end="opacity-100 scale-100 translate-y-0"
        class="bg-card border-border relative flex max-h-[90vh] w-full max-w-lg flex-col
          overflow-hidden border shadow-lg sm:rounded-lg"
      >
        <div class="border-border flex shrink-0 items-center justify-between border-b p-6">
          <h3 class="text-lg font-semibold" x-text="getModalTitle()"></h3>
          <button @click="closeModal()" class="text-muted-foreground hover:text-foreground">
            <i x-lucide="x" class="h-5 w-5"></i>
          </button>
        </div>
        <div class="space-y-4 overflow-y-auto p-6">
          <!-- Add Car Form -->
          <form x-show="modal.type === 'add-car'" @submit.prevent="submitAddCar" class="space-y-4">
            <div class="grid gap-2">
              <label class="text-sm font-medium">차량 번호</label>
              <input
                type="text"
                x-model="forms.car.number"
                required
                placeholder="예: 12가 3456"
                class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                  bg-transparent px-3 py-1 text-sm shadow-xs transition-colors focus-visible:ring-1
                  focus-visible:outline-none"
              />
            </div>
            <div class="grid grid-cols-2 gap-4">
              <div class="grid gap-2">
                <label class="text-sm font-medium">제조사</label>
                <input
                  type="text"
                  x-model="forms.car.maker"
                  required
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>
              <div class="grid gap-2">
                <label class="text-sm font-medium">차종</label>
                <input
                  type="text"
                  x-model="forms.car.model"
                  required
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>
            </div>
            <div class="grid grid-cols-2 gap-4">
              <div class="grid gap-2">
                <label class="text-sm font-medium">연식</label>
                <input
                  type="number"
                  x-model="forms.car.year"
                  required
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>
              <div class="grid gap-2">
                <label class="text-sm font-medium">연료</label>
                <select
                  x-model="forms.car.fuelType"
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                >
                  <option>휘발유</option>
                  <option>경유</option>
                  <option>LPG</option>
                  <option>전기</option>
                  <option>하이브리드</option>
                </select>
              </div>
            </div>
            <div class="grid gap-2">
              <label class="text-sm font-medium">현재 주행거리 (km)</label>
              <input
                type="number"
                x-model="forms.car.totalDistance"
                class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                  bg-transparent px-3 py-1 text-sm shadow-xs transition-colors focus-visible:ring-1
                  focus-visible:outline-none"
              />
            </div>
            <div class="flex justify-end pt-4">
              <button
                type="submit"
                class="bg-primary text-primary-foreground hover:bg-primary/90 inline-flex h-9
                  items-center justify-center rounded-md px-4 text-sm font-medium shadow
                  transition-colors"
              >
                저장
              </button>
            </div>
          </form>

          <!-- Add Record Form -->
          <form
            x-show="modal.type === 'add-record'"
            @submit.prevent="submitAddRecord"
            class="space-y-4"
          >
            <div class="grid grid-cols-2 gap-4">
              <div class="grid gap-2">
                <label class="text-sm font-medium">날짜</label>
                <input
                  type="date"
                  x-model="forms.record.date"
                  required
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>

              <!-- Autocomplete for Place -->
              <div class="relative grid gap-2" @click.outside="autocomplete.open = false">
                <label class="text-sm font-medium">장소</label>
                <input
                  type="text"
                  x-model="forms.record.place"
                  @focus="autocomplete.open = true"
                  @input="autocomplete.open = true"
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                  placeholder="장소 검색 또는 입력"
                />

                <!-- Dropdown -->
                <div
                  x-show="autocomplete.open && filteredPlaces.length > 0"
                  class="border-border bg-popover text-popover-foreground absolute top-full left-0
                    z-50 mt-1 w-full overflow-hidden rounded-md border shadow-md"
                >
                  <ul class="max-h-[200px] overflow-auto py-1">
                    <template x-for="place in filteredPlaces" :key="place">
                      <li
                        @click="forms.record.place = place; autocomplete.open = false"
                        class="hover:bg-accent hover:text-accent-foreground flex cursor-pointer
                          items-center gap-2 px-3 py-2 text-sm"
                      >
                        <i x-lucide="map-pin" class="text-muted-foreground h-3 w-3"></i>
                        <span x-text="place"></span>
                      </li>
                    </template>
                  </ul>
                </div>
              </div>
            </div>
            <div class="grid grid-cols-2 gap-4">
              <div class="grid gap-2">
                <label class="text-sm font-medium">누적 주행거리 (km)</label>
                <input
                  type="number"
                  x-model="forms.record.odometer"
                  required
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>
              <div class="grid gap-2">
                <label class="text-sm font-medium">금액 (원)</label>
                <input
                  type="number"
                  x-model="forms.record.amount"
                  @input="calculateVolume"
                  required
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>
            </div>
            <!-- Type: Refuel -->
            <div x-show="detail.tab === 'refuel'" class="border-border space-y-4 border-t pt-2">
              <div class="grid grid-cols-2 gap-4">
                <div class="grid gap-2">
                  <label class="text-sm font-medium">구분</label>
                  <select
                    x-model="forms.record.subType"
                    class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                      bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                      focus-visible:ring-1 focus-visible:outline-none"
                  >
                    <option value="full">가득(상한)</option>
                    <option value="partial">부분주유</option>
                  </select>
                </div>
                <div class="grid gap-2">
                  <label class="text-sm font-medium">단가 (원/L)</label>
                  <input
                    type="number"
                    x-model="forms.record.unitPrice"
                    @input="calculateVolume"
                    class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                      bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                      focus-visible:ring-1 focus-visible:outline-none"
                  />
                </div>
              </div>
              <div class="grid grid-cols-2 gap-4">
                <div class="grid gap-2">
                  <label class="text-sm font-medium">주유량 (L)</label>
                  <input
                    type="number"
                    step="0.01"
                    x-model="forms.record.volume"
                    class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                      bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                      focus-visible:ring-1 focus-visible:outline-none"
                  />
                </div>
                <div class="grid gap-2" x-show="forms.record.subType !== 'full'">
                  <label class="text-sm font-medium">연료게이지 (%)</label>
                  <input
                    type="number"
                    x-model="forms.record.fuelGauge"
                    class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                      bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                      focus-visible:ring-1 focus-visible:outline-none"
                  />
                </div>
              </div>
              <label
                class="border-input bg-accent/30 flex cursor-pointer items-center gap-2 rounded-md
                  border px-3 py-2"
              >
                <input
                  type="checkbox"
                  x-model="forms.record.prevRefuelUnknown"
                  class="text-brand border-input h-4 w-4 rounded"
                />
                <span class="text-muted-foreground text-xs"
                  >이전 주유이력이 불분명함 (이번 기록은 연비 계산에서 제외)</span
                >
              </label>
            </div>
            <!-- Type: Maintenance -->
            <div
              x-show="detail.tab === 'maintenance'"
              class="border-border space-y-4 border-t pt-2"
            >
              <div class="grid grid-cols-2 gap-4">
                <div class="grid gap-2">
                  <label class="text-sm font-medium">구분</label>
                  <select
                    x-model="forms.record.subType"
                    class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                      bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                      focus-visible:ring-1 focus-visible:outline-none"
                  >
                    <option value="maintenance">정비</option>
                    <option value="inspection">점검</option>
                  </select>
                </div>
                <div class="grid gap-2">
                  <label class="text-sm font-medium">항목</label>
                  <input
                    type="text"
                    x-model="forms.record.item"
                    placeholder="엔진오일 교환"
                    class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                      bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                      focus-visible:ring-1 focus-visible:outline-none"
                  />
                </div>
              </div>
              <div class="grid gap-2">
                <label class="text-sm font-medium">메모</label>
                <textarea
                  x-model="forms.record.memo"
                  class="border-input placeholder:text-muted-foreground focus-visible:ring-ring flex
                    min-h-[60px] w-full rounded-md border bg-transparent px-3 py-2 text-sm shadow-xs
                    focus-visible:ring-1 focus-visible:outline-none"
                >
                </textarea>
              </div>
            </div>
            <!-- Type: Etc -->
            <div x-show="detail.tab === 'etc'" class="border-border space-y-4 border-t pt-2">
              <div class="grid gap-2">
                <label class="text-sm font-medium">항목</label>
                <input
                  type="text"
                  x-model="forms.record.item"
                  placeholder="세차, 주차비 등"
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>
              <div class="grid gap-2">
                <label class="text-sm font-medium">메모</label>
                <textarea
                  x-model="forms.record.memo"
                  class="border-input placeholder:text-muted-foreground focus-visible:ring-ring flex
                    min-h-[60px] w-full rounded-md border bg-transparent px-3 py-2 text-sm shadow-xs
                    focus-visible:ring-1 focus-visible:outline-none"
                >
                </textarea>
              </div>
            </div>
            <div class="flex justify-end pt-4">
              <button
                type="submit"
                class="bg-primary text-primary-foreground hover:bg-primary/90 inline-flex h-9
                  items-center justify-center rounded-md px-4 text-sm font-medium shadow
                  transition-colors"
              >
                추가하기
              </button>
            </div>
          </form>

          <!-- Add Maintenance Timer Form -->
          <form
            x-show="modal.type === 'add-maintenance-timer'"
            @submit.prevent="submitAddMaintenanceTimer"
            class="space-y-4"
          >
            <div class="grid gap-2">
              <label class="text-sm font-medium">타이머 제목</label>
              <input
                type="text"
                x-model="forms.maintenanceTimer.title"
                required
                placeholder="예: 엔진오일 교환"
                class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                  bg-transparent px-3 py-1 text-sm shadow-xs transition-colors focus-visible:ring-1
                  focus-visible:outline-none"
              />
            </div>

            <div class="grid grid-cols-2 gap-4">
              <div class="grid gap-2">
                <label class="text-sm font-medium">마일리지 조건 (km)</label>
                <input
                  type="number"
                  min="1"
                  x-model="forms.maintenanceTimer.mileageIntervalKm"
                  placeholder="예: 7000"
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>
              <div class="grid gap-2">
                <label class="text-sm font-medium">시간 조건 (일)</label>
                <input
                  type="number"
                  min="1"
                  x-model="forms.maintenanceTimer.timeIntervalDays"
                  placeholder="예: 180"
                  class="border-input focus-visible:ring-ring flex h-9 w-full rounded-md border
                    bg-transparent px-3 py-1 text-sm shadow-xs transition-colors
                    focus-visible:ring-1 focus-visible:outline-none"
                />
              </div>
            </div>

            <label
              class="border-input bg-accent/30 flex cursor-pointer items-center gap-2 rounded-md
                border px-3 py-2"
            >
              <input
                type="checkbox"
                x-model="forms.maintenanceTimer.repeat"
                class="text-brand border-input h-4 w-4 rounded"
              />
              <span class="text-muted-foreground text-xs"
                >완료 후 자동으로 다음 주기를 시작합니다.</span
              >
            </label>

            <p class="text-muted-foreground text-xs">
              마일리지 조건 또는 시간 조건 중 하나 이상 입력해야 합니다.
            </p>

            <div class="flex justify-end pt-2">
              <button
                type="submit"
                class="bg-primary text-primary-foreground hover:bg-primary/90 inline-flex h-9
                  items-center justify-center rounded-md px-4 text-sm font-medium shadow
                  transition-colors"
              >
                추가하기
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>

    <!-- Toast -->
    <div
      class="pointer-events-none fixed bottom-6 left-1/2 z-[60] flex -translate-x-1/2 flex-col
        gap-2"
    >
      <template x-for="toast in toasts" :key="toast.id">
        <div
          x-show="toast.visible"
          x-transition:enter="transition ease-out duration-300"
          x-transition:enter-start="translate-y-2 opacity-0"
          x-transition:enter-end="translate-y-0 opacity-100"
          class="bg-background inline-flex items-center justify-center rounded-md border px-4 py-2.5
            text-sm font-medium shadow-md transition-all"
          :class="({
            'border-border text-foreground': toast.type === 'info',
            'border-green-900 bg-green-950 text-green-100': toast.type === 'success',
            'border-red-900 bg-red-950 text-red-100': toast.type === 'error',
          })"
        >
          <span x-text="toast.message"></span>
        </div>
      </template>
    </div>

    <script>
      const createEmptyDatabase = () => ({
        config: { type: 'clxdb' },
        cars: [],
        records: [],
        maintenanceTimers: [],
      });

      const DAY_IN_MS = 24 * 60 * 60 * 1000;

      const isFullRefuelRecord = record => String(record?.subType || 'full') !== 'partial';

      const hasUnknownPreviousRefuel = record => Boolean(record?.prevRefuelUnknown);

      const calculateRefuelEfficiencyEntries = (records, limit = Infinity) => {
        const entries = [];
        const maxEntries = Number.isFinite(limit) ? Math.max(1, Number(limit) || 1) : Infinity;

        let startFullRecord = null;
        let consumedVolume = 0;
        let intervalValid = true;

        const chronologicalRecords = [...(records || [])].reverse();

        for (const record of chronologicalRecords) {
          const volume = Number(record?.volume) || 0;
          if (volume <= 0) continue;

          if (!startFullRecord) {
            if (!isFullRefuelRecord(record)) continue;
            startFullRecord = record;
            consumedVolume = 0;
            intervalValid = true;
            continue;
          }

          if (hasUnknownPreviousRefuel(record)) {
            intervalValid = false;
          }

          consumedVolume += volume;

          if (!isFullRefuelRecord(record)) continue;

          const distance = (Number(record.odometer) || 0) - (Number(startFullRecord.odometer) || 0);
          if (intervalValid && distance > 0 && consumedVolume > 0) {
            entries.push({
              recordId: String(record.id || ''),
              date: String(record.date || '').substring(5),
              dist: distance,
              eff: (distance / consumedVolume).toFixed(1),
            });
          }

          startFullRecord = record;
          consumedVolume = 0;
          intervalValid = true;
        }

        return Number.isFinite(maxEntries) ? entries.slice(-maxEntries) : entries;
      };

      class DexieClxBackend {
        constructor() {
          this.uuid = null;
          this.dexie = null;
          this.listeners = new Set();
        }

        isReady() {
          return this.dexie !== null;
        }

        close() {
          if (this.dexie) {
            this.dexie.close();
            this.dexie = null;
          }
          this.uuid = null;
          this.listeners.clear();
        }

        getTable() {
          if (!this.dexie) {
            throw new Error('Local Dexie database is not initialized.');
          }
          return this.dexie.table('documents');
        }

        isEntityDocumentId(id) {
          return id.startsWith('car:') || id.startsWith('record:');
        }

        isMaintenanceTimerDocumentId(id) {
          return id.startsWith('meta:maintenanceTimers:');
        }

        getMaintenanceTimerDocumentId(carId) {
          return `meta:maintenanceTimers:${carId}`;
        }

        getCarIdFromMaintenanceTimerDocumentId(id) {
          const prefix = 'meta:maintenanceTimers:';
          if (!id.startsWith(prefix)) return null;

          const carId = id.slice(prefix.length);
          return carId ? String(carId) : null;
        }

        getDocumentKind(id) {
          if (id.startsWith('car:')) return 'car';
          if (id.startsWith('record:')) return 'record';
          return 'meta';
        }

        getCarIdFromRecordData(data) {
          const carId = data?.carId;
          return carId ? String(carId) : null;
        }

        isPlaceCounterDocumentId(id) {
          return id.startsWith('meta:places:');
        }

        toIsoDateTime(value, fallbackValue = null) {
          const valueText = String(value || '').trim();
          const parsedValueTimestamp = valueText ? Date.parse(valueText) : NaN;
          if (Number.isFinite(parsedValueTimestamp)) {
            return new Date(parsedValueTimestamp).toISOString();
          }

          const fallbackText = String(fallbackValue || '').trim();
          const parsedFallbackTimestamp = fallbackText ? Date.parse(fallbackText) : NaN;
          if (Number.isFinite(parsedFallbackTimestamp)) {
            return new Date(parsedFallbackTimestamp).toISOString();
          }

          return new Date().toISOString();
        }

        normalizeMaintenanceTimer(rawTimer) {
          const title = String(rawTimer?.title || '').trim();
          if (!title) return null;

          const mileageIntervalKm = Number(rawTimer?.mileageIntervalKm);
          const normalizedMileageIntervalKm =
            Number.isFinite(mileageIntervalKm) && mileageIntervalKm > 0
              ? Math.round(mileageIntervalKm)
              : null;

          const timeIntervalDays = Number(rawTimer?.timeIntervalDays);
          const normalizedTimeIntervalDays =
            Number.isFinite(timeIntervalDays) && timeIntervalDays > 0
              ? Math.round(timeIntervalDays)
              : null;

          if (!normalizedMileageIntervalKm && !normalizedTimeIntervalDays) {
            return null;
          }

          const baseOdometerKm = Number(rawTimer?.baseOdometerKm);
          const normalizedBaseOdometerKm =
            Number.isFinite(baseOdometerKm) && baseOdometerKm >= 0 ? baseOdometerKm : 0;

          return {
            id: String(rawTimer?.id || crypto.randomUUID()),
            title,
            mileageIntervalKm: normalizedMileageIntervalKm,
            timeIntervalDays: normalizedTimeIntervalDays,
            repeat: Boolean(rawTimer?.repeat),
            baseOdometerKm: normalizedBaseOdometerKm,
            baseStartedAt: this.toIsoDateTime(rawTimer?.baseStartedAt, rawTimer?.createdAt),
            createdAt: this.toIsoDateTime(rawTimer?.createdAt, rawTimer?.baseStartedAt),
          };
        }

        normalizeMaintenanceTimers(rawTimers) {
          if (!Array.isArray(rawTimers)) return [];

          return rawTimers
            .map(rawTimer => this.normalizeMaintenanceTimer(rawTimer))
            .filter(Boolean);
        }

        normalizePlaceId(place) {
          return String(place || '')
            .trim()
            .toLowerCase();
        }

        toDayStartTimestamp(dateText) {
          const text = String(dateText || '').trim();
          if (!text) return null;

          const timestamp = Date.parse(`${text}T00:00:00`);
          return Number.isFinite(timestamp) ? timestamp : null;
        }

        toDayEndTimestamp(dateText) {
          const text = String(dateText || '').trim();
          if (!text) return null;

          const timestamp = Date.parse(`${text}T23:59:59.999`);
          return Number.isFinite(timestamp) ? timestamp : null;
        }

        toRecordTimestamp(data) {
          const explicitTimestamp = Number(data?.dateTs);
          if (Number.isFinite(explicitTimestamp)) {
            return explicitTimestamp;
          }

          if (typeof data?.date === 'number' && Number.isFinite(data.date)) {
            return data.date;
          }

          const rawDate = String(data?.date || '').trim();
          if (!rawDate) return 0;

          if (/^\d+$/.test(rawDate)) {
            const parsedTimestamp = Number(rawDate);
            if (Number.isFinite(parsedTimestamp)) {
              return parsedTimestamp;
            }
          }

          const timestamp = Date.parse(rawDate.length <= 10 ? `${rawDate}T00:00:00` : rawDate);
          return Number.isFinite(timestamp) ? timestamp : 0;
        }

        formatDateFromTimestamp(timestamp) {
          const normalizedTimestamp = Number(timestamp);
          if (!Number.isFinite(normalizedTimestamp)) return '';

          const date = new Date(normalizedTimestamp);
          if (Number.isNaN(date.getTime())) return '';

          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        }

        withLocalIndexes(document) {
          const kind = this.getDocumentKind(document.id);
          const isRecord = kind === 'record';
          const isMaintenanceTimerMeta =
            kind === 'meta' && this.isMaintenanceTimerDocumentId(document.id);
          const recordDateTs = isRecord ? this.toRecordTimestamp(document.data) : null;

          return {
            id: document.id,
            at: document.at,
            seq: document.seq,
            del: document.del,
            data: document.data,
            kind,
            carId: isRecord
              ? this.getCarIdFromRecordData(document.data)
              : kind === 'car'
                ? document.id.slice(4)
                : isMaintenanceTimerMeta
                  ? this.getCarIdFromMaintenanceTimerDocumentId(document.id)
                  : null,
            recordType: isRecord ? String(document.data?.type || '') : null,
            recordDateTs: isRecord ? recordDateTs : null,
            recordOdometer: isRecord ? Number(document.data?.odometer) || 0 : null,
            recordSubType: isRecord ? String(document.data?.subType || '') : null,
            placeId: isRecord ? this.normalizePlaceId(document.data?.place) || null : null,
          };
        }

        toDatabaseDocument(row) {
          return {
            id: row.id,
            at: row.at,
            seq: row.seq < 0 ? null : row.seq,
            del: row.del,
            data: row.data,
          };
        }

        toCarEntity(row) {
          const car = { ...(row.data || {}) };
          if (!car.id) car.id = row.id.slice(4);
          return car;
        }

        toRecordEntity(row) {
          const record = { ...(row.data || {}) };
          if (!record.id) record.id = row.id.slice(7);
          if (!record.carId && row.carId) {
            record.carId = row.carId;
          }
          if (!record.date && Number.isFinite(row.recordDateTs)) {
            record.date = this.formatDateFromTimestamp(row.recordDateTs);
          }
          return record;
        }

        getRecordIndexName() {
          return '[kind+carId+recordType+recordDateTs+recordOdometer+id]';
        }

        buildRecordCursorFromRow(row) {
          return {
            dateTs: Number(row.recordDateTs) || 0,
            odometer: Number(row.recordOdometer) || 0,
            id: String(row.id || ''),
          };
        }

        normalizeRecordCursor(cursor) {
          if (!cursor || typeof cursor !== 'object') return null;

          return {
            dateTs: Number(cursor.dateTs) || 0,
            odometer: Number(cursor.odometer) || 0,
            id: String(cursor.id || ''),
          };
        }

        recordMatchesSearch(row, normalizedSearch) {
          if (!normalizedSearch) return true;

          const record = row.data || {};
          const haystack =
            `${record.item || ''}${record.place || ''}${record.memo || ''}`.toLowerCase();
          return haystack.includes(normalizedSearch);
        }

        recordMatchesMaintenanceType(row, tab, maintenanceType) {
          if (tab !== 'maintenance') return true;
          if (!maintenanceType || maintenanceType === 'all') return true;

          return String(row.recordSubType || row.data?.subType || '') === maintenanceType;
        }

        getRecordRangeLowerKey(carId, tab, dateStartTs) {
          return [
            'record',
            String(carId),
            String(tab),
            Number.isFinite(dateStartTs) ? dateStartTs : Dexie.minKey,
            Dexie.minKey,
            Dexie.minKey,
          ];
        }

        getRecordRangeUpperKey(carId, tab, dateEndTs, cursor) {
          if (cursor) {
            return [
              'record',
              String(carId),
              String(tab),
              Number(cursor.dateTs) || 0,
              Number(cursor.odometer) || 0,
              String(cursor.id || ''),
            ];
          }

          return [
            'record',
            String(carId),
            String(tab),
            Number.isFinite(dateEndTs) ? dateEndTs : Dexie.maxKey,
            Dexie.maxKey,
            Dexie.maxKey,
          ];
        }

        async readRecordRowsChunk({
          carId,
          tab,
          cursor = null,
          dateStartTs = null,
          dateEndTs = null,
          limit = 80,
        }) {
          if (!carId || !tab) return [];

          const normalizedCursor = this.normalizeRecordCursor(cursor);
          const lowerKey = this.getRecordRangeLowerKey(carId, tab, dateStartTs);
          const upperKey = this.getRecordRangeUpperKey(carId, tab, dateEndTs, normalizedCursor);

          return this.getTable()
            .where(this.getRecordIndexName())
            .between(lowerKey, upperKey, true, !normalizedCursor)
            .reverse()
            .limit(Math.max(1, Number(limit) || 1))
            .toArray();
        }

        getPlaceCounterDocumentId(carId) {
          return `meta:places:${carId}`;
        }

        placeCounterMapFromEntries(entries = []) {
          const counter = new Map();

          for (const entry of entries) {
            const placeId = this.normalizePlaceId(entry?.id || entry?.name || '');
            if (!placeId) continue;

            const occurrence = Math.max(0, Number(entry?.occurrence) || 0);
            if (occurrence <= 0) continue;

            const existing = counter.get(placeId);
            if (existing) {
              existing.occurrence += occurrence;
              if (!existing.name && entry?.name) {
                existing.name = String(entry.name).trim();
              }
              continue;
            }

            const name = String(entry?.name || '').trim();
            counter.set(placeId, {
              id: placeId,
              name: name || placeId,
              occurrence,
            });
          }

          return counter;
        }

        placeCounterEntriesFromMap(counter) {
          return Array.from(counter.values())
            .filter(entry => entry.occurrence > 0)
            .sort((a, b) => {
              if (b.occurrence !== a.occurrence) return b.occurrence - a.occurrence;
              return a.name.localeCompare(b.name);
            });
        }

        adjustPlaceCounterMap(counter, placeName, delta) {
          const normalizedName = String(placeName || '').trim();
          const placeId = this.normalizePlaceId(normalizedName);
          if (!placeId || !delta) return false;

          const existing = counter.get(placeId);
          if (!existing) {
            if (delta <= 0) return false;
            counter.set(placeId, {
              id: placeId,
              name: normalizedName || placeId,
              occurrence: delta,
            });
            return true;
          }

          existing.occurrence += delta;
          if (normalizedName) {
            existing.name = normalizedName;
          }

          if (existing.occurrence <= 0) {
            counter.delete(placeId);
          }

          return true;
        }

        async applyPlaceCounterDelta(carId, previousPlace, nextPlace, atHint = Date.now()) {
          const normalizedCarId = String(carId || '');
          if (!normalizedCarId) return;

          const previousName = String(previousPlace || '').trim();
          const nextName = String(nextPlace || '').trim();
          const previousId = this.normalizePlaceId(previousName);
          const nextId = this.normalizePlaceId(nextName);

          if (!previousId && !nextId) return;

          const table = this.getTable();
          const documentId = this.getPlaceCounterDocumentId(normalizedCarId);
          const existing = await table.get(documentId);
          if (!existing) {
            const fallbackEntries = await this.readPlaceCounterFallback(normalizedCarId);
            if (!fallbackEntries.length) return;

            await table.put(
              this.withLocalIndexes({
                id: documentId,
                at: Math.max(Number(atHint) || Date.now(), Date.now()),
                seq: -1,
                del: false,
                data: {
                  carId: normalizedCarId,
                  places: fallbackEntries,
                },
              })
            );
            return;
          }

          const counter = this.placeCounterMapFromEntries(existing?.data?.places || []);

          let changed = false;

          if (previousId && previousId !== nextId) {
            changed = this.adjustPlaceCounterMap(counter, previousName, -1) || changed;
          }

          if (nextId && nextId !== previousId) {
            changed = this.adjustPlaceCounterMap(counter, nextName, 1) || changed;
          }

          if (previousId && nextId && previousId === nextId && nextName) {
            const entry = counter.get(nextId);
            if (entry && entry.name !== nextName) {
              entry.name = nextName;
              changed = true;
            }
          }

          if (!changed) return;

          const at = Math.max(Number(atHint) || Date.now(), (existing?.at ?? 0) + 1);
          if (!counter.size) {
            if (!existing) return;

            await table.put(
              this.withLocalIndexes({
                id: documentId,
                at,
                seq: -1,
                del: true,
                data: undefined,
              })
            );
            return;
          }

          await table.put(
            this.withLocalIndexes({
              id: documentId,
              at,
              seq: -1,
              del: false,
              data: {
                carId: normalizedCarId,
                places: this.placeCounterEntriesFromMap(counter),
              },
            })
          );
        }

        async readPlaceCounterFallback(carId) {
          const normalizedCarId = String(carId || '');
          if (!normalizedCarId) return [];

          const rows = await this.getTable()
            .where('[kind+carId]')
            .equals(['record', normalizedCarId])
            .toArray();
          const counter = new Map();

          for (const row of rows) {
            if (row.del || !row.data) continue;
            this.adjustPlaceCounterMap(counter, row.data.place, 1);
          }

          return this.placeCounterEntriesFromMap(counter);
        }

        notifyReplicate() {
          for (const onUpdate of this.listeners) {
            try {
              onUpdate();
            } catch (error) {
              console.error(error);
            }
          }
        }

        async initialize(uuid) {
          if (this.dexie && this.uuid === uuid) {
            return;
          }

          if (this.dexie) {
            this.dexie.close();
          }

          this.uuid = uuid;
          this.dexie = new Dexie(`vehlog_clxdb_${uuid}`);
          this.dexie.version(2).stores({
            documents:
              '&id, seq, del, at, kind, carId, [kind+carId], [kind+carId+recordType+recordDateTs+recordOdometer+id], [kind+carId+recordType+placeId]',
          });
          await this.dexie.open();
        }

        async read(ids) {
          const rows = await this.getTable().bulkGet(ids);
          return rows.map(row => (row ? this.toDatabaseDocument(row) : null));
        }

        async readPendingIds() {
          const ids = await this.getTable().where('seq').equals(-1).primaryKeys();
          return ids.map(id => String(id));
        }

        async upsert(data) {
          if (!data.length) return;

          await this.getTable().bulkPut(
            data.map(document =>
              this.withLocalIndexes({
                id: document.id,
                at: document.at,
                seq: document.seq,
                del: document.del,
                data: document.data,
              })
            )
          );
        }

        async delete(data) {
          if (!data.length) return;

          await this.getTable().bulkDelete(data.map(document => document.id));
        }

        async readCars() {
          const rows = await this.getTable().where('kind').equals('car').toArray();
          const cars = rows.filter(row => !row.del && row.data).map(row => this.toCarEntity(row));

          cars.sort((a, b) => String(b.createdAt || '').localeCompare(String(a.createdAt || '')));
          return cars;
        }

        async readRecordsPage({ carId, tab, filters = {}, cursor = null, limit = 20 }) {
          if (!carId || !tab) {
            return {
              items: [],
              cursor: null,
              nextCursor: null,
              hasNext: false,
            };
          }

          const normalizedTab = String(tab);
          const normalizedCursor = this.normalizeRecordCursor(cursor);
          const normalizedSearch = String(filters.search || '')
            .trim()
            .toLowerCase();
          const maintenanceType = String(filters.maintenanceType || 'all');
          const dateStartTs = this.toDayStartTimestamp(filters.dateStart);
          const dateEndTs = this.toDayEndTimestamp(filters.dateEnd);

          if (
            Number.isFinite(dateStartTs) &&
            Number.isFinite(dateEndTs) &&
            Number(dateStartTs) > Number(dateEndTs)
          ) {
            return {
              items: [],
              cursor: normalizedCursor,
              nextCursor: null,
              hasNext: false,
            };
          }

          const pageSize = Math.max(1, Math.min(100, Number(limit) || 20));
          const chunkSize = Math.max(pageSize * 3, 80);
          const acceptedRows = [];

          let scanCursor = normalizedCursor;
          let exhausted = false;
          let safetyCount = 0;

          while (acceptedRows.length < pageSize + 1 && !exhausted && safetyCount < 300) {
            safetyCount += 1;

            const rows = await this.readRecordRowsChunk({
              carId,
              tab: normalizedTab,
              cursor: scanCursor,
              dateStartTs,
              dateEndTs,
              limit: chunkSize,
            });

            if (!rows.length) {
              exhausted = true;
              break;
            }

            for (const row of rows) {
              if (row.del || !row.data) continue;
              if (!this.recordMatchesMaintenanceType(row, normalizedTab, maintenanceType)) continue;
              if (!this.recordMatchesSearch(row, normalizedSearch)) continue;

              acceptedRows.push(row);
              if (acceptedRows.length >= pageSize + 1) {
                break;
              }
            }

            if (rows.length < chunkSize) {
              exhausted = true;
              break;
            }

            scanCursor = this.buildRecordCursorFromRow(rows[rows.length - 1]);
          }

          const pageRows = acceptedRows.slice(0, pageSize);
          const hasNext = acceptedRows.length > pageSize || (!exhausted && safetyCount >= 300);

          return {
            items: pageRows.map(row => this.toRecordEntity(row)),
            cursor: normalizedCursor,
            nextCursor:
              hasNext && pageRows.length
                ? this.buildRecordCursorFromRow(pageRows[pageRows.length - 1])
                : null,
            hasNext,
          };
        }

        async readPlaceCounter(carId) {
          if (!carId) return [];

          const row = await this.getTable().get(this.getPlaceCounterDocumentId(carId));
          if (row && !row.del && row.data) {
            return this.placeCounterEntriesFromMap(
              this.placeCounterMapFromEntries(row.data.places || [])
            );
          }

          return this.readPlaceCounterFallback(carId);
        }

        async readMaintenanceTimers(carId) {
          const normalizedCarId = String(carId || '');
          if (!normalizedCarId) return [];

          const row = await this.getTable().get(
            this.getMaintenanceTimerDocumentId(normalizedCarId)
          );
          if (!row || row.del || !row.data) return [];

          return this.normalizeMaintenanceTimers(row.data.timers || []);
        }

        async stageMaintenanceTimers(carId, timers) {
          const normalizedCarId = String(carId || '');
          if (!normalizedCarId) return;

          const normalizedTimers = this.normalizeMaintenanceTimers(timers);
          const documentId = this.getMaintenanceTimerDocumentId(normalizedCarId);

          if (!normalizedTimers.length) {
            await this.stageDeleteDocument(documentId);
            return;
          }

          await this.stageUpsertDocument(documentId, {
            carId: normalizedCarId,
            timers: normalizedTimers,
          });
        }

        async readRecordCarIds(documentIds) {
          if (!documentIds?.length) return {};

          const rows = await this.getTable().bulkGet(documentIds);
          const carIdsByDocumentId = {};

          for (let i = 0; i < documentIds.length; i++) {
            const row = rows[i];
            if (row?.kind !== 'record') continue;

            const carId = this.getCarIdFromRecordData(row.data);
            if (carId) {
              carIdsByDocumentId[documentIds[i]] = carId;
            }
          }

          return carIdsByDocumentId;
        }

        async readMonthlyRefuelCost(carId) {
          if (!carId) return { current: 0, diff: 0 };

          const now = new Date();
          const currentMonthStart = new Date(now.getFullYear(), now.getMonth(), 1).getTime();
          const nextMonthStart = new Date(now.getFullYear(), now.getMonth() + 1, 1).getTime();
          const previousMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1).getTime();

          let currentTotal = 0;
          let lastTotal = 0;

          let cursor = null;
          const chunkSize = 200;

          while (true) {
            const rows = await this.readRecordRowsChunk({
              carId,
              tab: 'refuel',
              cursor,
              dateStartTs: previousMonthStart,
              dateEndTs: nextMonthStart - 1,
              limit: chunkSize,
            });

            if (!rows.length) {
              break;
            }

            for (const row of rows) {
              if (row.del || !row.data) continue;

              const timestamp = Number(row.recordDateTs);
              if (!Number.isFinite(timestamp)) continue;

              const amount = Number(row.data.amount) || 0;
              if (timestamp >= currentMonthStart && timestamp < nextMonthStart) {
                currentTotal += amount;
                continue;
              }

              if (timestamp >= previousMonthStart && timestamp < currentMonthStart) {
                lastTotal += amount;
              }
            }

            if (rows.length < chunkSize) {
              break;
            }

            cursor = this.buildRecordCursorFromRow(rows[rows.length - 1]);
          }

          return { current: currentTotal, diff: currentTotal - lastTotal };
        }

        async readEfficiencyHistory(carId, limit = 20) {
          if (!carId) return [];

          const historyLimit = Math.max(1, Math.min(50, Number(limit) || 20));
          const recentRefuels = [];
          let fullRefuelCount = 0;

          let cursor = null;
          const chunkSize = Math.max(60, historyLimit * 3);
          let safetyCount = 0;

          while (fullRefuelCount < historyLimit + 1 && safetyCount < 300) {
            safetyCount += 1;

            const rows = await this.readRecordRowsChunk({
              carId,
              tab: 'refuel',
              cursor,
              limit: chunkSize,
            });

            if (!rows.length) {
              break;
            }

            for (const row of rows) {
              if (row.del || !row.data) continue;

              const volume = Number(row.data.volume) || 0;
              if (volume <= 0) continue;

              const record = this.toRecordEntity(row);
              recentRefuels.push(record);

              if (isFullRefuelRecord(record)) {
                fullRefuelCount += 1;
              }

              if (fullRefuelCount >= historyLimit + 1) {
                break;
              }
            }

            if (rows.length < chunkSize) {
              break;
            }

            cursor = this.buildRecordCursorFromRow(rows[rows.length - 1]);
          }

          const history = calculateRefuelEfficiencyEntries(recentRefuels, historyLimit).map(
            entry => ({
              date: entry.date,
              val: parseFloat(entry.eff),
            })
          );

          return history;
        }

        replicate(onUpdate) {
          this.listeners.add(onUpdate);
          return () => this.listeners.delete(onUpdate);
        }

        async stageUpsertDocument(id, data) {
          const table = this.getTable();
          const existing = id.startsWith('record:') ? await table.get(id) : null;
          const now = Date.now();

          await table.put(
            this.withLocalIndexes({
              id,
              at: now,
              seq: -1,
              del: false,
              data,
            })
          );

          if (id.startsWith('record:')) {
            const previousData = existing?.del ? undefined : existing?.data;
            const previousCarId = this.getCarIdFromRecordData(previousData);
            const currentCarId = this.getCarIdFromRecordData(data);

            if (previousCarId && previousCarId !== currentCarId) {
              await this.applyPlaceCounterDelta(previousCarId, previousData?.place, null, now + 1);
            }

            if (currentCarId) {
              await this.applyPlaceCounterDelta(
                currentCarId,
                previousCarId === currentCarId ? previousData?.place : null,
                data?.place,
                now + 2
              );
            }
          }

          this.notifyReplicate();
        }

        async stageDeleteDocument(id) {
          const table = this.getTable();
          const existing = await table.get(id);
          const tombstoneAt = Math.max(Date.now(), (existing?.at ?? 0) + 1);

          await table.put(
            this.withLocalIndexes({
              id,
              at: tombstoneAt,
              seq: -1,
              del: true,
              data: undefined,
            })
          );

          if (id.startsWith('record:')) {
            const existingCarId = this.getCarIdFromRecordData(existing?.data);
            if (existingCarId) {
              await this.applyPlaceCounterDelta(
                existingCarId,
                existing?.data?.place,
                null,
                tombstoneAt + 1
              );
            }
          } else if (id.startsWith('car:')) {
            const carId = id.slice(4);

            await table.put(
              this.withLocalIndexes({
                id: this.getPlaceCounterDocumentId(carId),
                at: tombstoneAt + 1,
                seq: -1,
                del: true,
                data: undefined,
              })
            );

            await table.put(
              this.withLocalIndexes({
                id: this.getMaintenanceTimerDocumentId(carId),
                at: tombstoneAt + 2,
                seq: -1,
                del: true,
                data: undefined,
              })
            );
          }

          this.notifyReplicate();
        }

        async loadSnapshot() {
          const snapshot = createEmptyDatabase();
          const [carRows, recordRows, maintenanceTimerRows] = await Promise.all([
            this.getTable().where('kind').equals('car').toArray(),
            this.getTable().where('kind').equals('record').toArray(),
            this.getTable().where('id').startsWith('meta:maintenanceTimers:').toArray(),
          ]);

          for (const row of carRows) {
            if (row.del || !row.data) continue;
            snapshot.cars.push(this.toCarEntity(row));
          }

          for (const row of recordRows) {
            if (row.del || !row.data) continue;
            snapshot.records.push(this.toRecordEntity(row));
          }

          for (const row of maintenanceTimerRows) {
            if (row.del || !row.data) continue;

            const carId =
              row.data?.carId || this.getCarIdFromMaintenanceTimerDocumentId(String(row.id || ''));
            const timers = this.normalizeMaintenanceTimers(row.data?.timers || []);
            if (!carId || !timers.length) continue;

            snapshot.maintenanceTimers.push({
              carId: String(carId),
              timers,
            });
          }

          return snapshot;
        }

        async importSnapshot(rawSnapshot) {
          const snapshot = rawSnapshot || {};
          const cars = Array.isArray(snapshot.cars) ? snapshot.cars : [];
          const records = Array.isArray(snapshot.records) ? snapshot.records : [];
          const maintenanceTimers = Array.isArray(snapshot.maintenanceTimers)
            ? snapshot.maintenanceTimers
            : [];
          const table = this.getTable();
          const desiredDocuments = [];
          const desiredIds = new Set();
          const placeCountersByCar = new Map();
          const maintenanceTimersByCar = new Map();
          let at = Date.now();

          for (const rawCar of cars) {
            const id = String(rawCar?.id || crypto.randomUUID());
            const car = { ...(rawCar || {}), id };
            desiredIds.add(`car:${id}`);
            desiredDocuments.push(
              this.withLocalIndexes({
                id: `car:${id}`,
                at: ++at,
                seq: -1,
                del: false,
                data: car,
              })
            );
          }

          for (const rawRecord of records) {
            const id = String(rawRecord?.id || crypto.randomUUID());
            const record = { ...(rawRecord || {}), id };
            desiredIds.add(`record:${id}`);

            const carId = this.getCarIdFromRecordData(record);
            const placeName = String(record.place || '').trim();
            if (carId && placeName) {
              if (!placeCountersByCar.has(carId)) {
                placeCountersByCar.set(carId, new Map());
              }
              this.adjustPlaceCounterMap(placeCountersByCar.get(carId), placeName, 1);
            }

            desiredDocuments.push(
              this.withLocalIndexes({
                id: `record:${id}`,
                at: ++at,
                seq: -1,
                del: false,
                data: record,
              })
            );
          }

          for (const rawTimerEntry of maintenanceTimers) {
            const carId = String(rawTimerEntry?.carId || '').trim();
            if (!carId) continue;

            maintenanceTimersByCar.set(
              carId,
              this.normalizeMaintenanceTimers(rawTimerEntry?.timers)
            );
          }

          for (const [carId, timers] of maintenanceTimersByCar.entries()) {
            if (!timers.length) continue;

            const id = this.getMaintenanceTimerDocumentId(carId);
            desiredIds.add(id);
            desiredDocuments.push(
              this.withLocalIndexes({
                id,
                at: ++at,
                seq: -1,
                del: false,
                data: { carId, timers },
              })
            );
          }

          for (const [carId, counter] of placeCountersByCar.entries()) {
            const places = this.placeCounterEntriesFromMap(counter);
            if (!places.length) continue;

            const id = this.getPlaceCounterDocumentId(carId);
            desiredIds.add(id);
            desiredDocuments.push(
              this.withLocalIndexes({
                id,
                at: ++at,
                seq: -1,
                del: false,
                data: { carId, places },
              })
            );
          }

          const rows = await table.toArray();
          const tombstones = rows
            .filter(
              row =>
                (this.isEntityDocumentId(row.id) ||
                  this.isPlaceCounterDocumentId(row.id) ||
                  this.isMaintenanceTimerDocumentId(row.id)) &&
                !desiredIds.has(row.id)
            )
            .map(row =>
              this.withLocalIndexes({
                id: row.id,
                at: ++at,
                seq: -1,
                del: true,
                data: undefined,
              })
            );

          await this.dexie.transaction('rw', this.dexie.documents, async () => {
            if (desiredDocuments.length) {
              await table.bulkPut(desiredDocuments);
            }
            if (tombstones.length) {
              await table.bulkPut(tombstones);
            }
          });

          this.notifyReplicate();
        }
      }

      document.addEventListener('alpine:init', () => {
        Alpine.directive('lucide', (el, { expression }, { evaluate }) => {
          if (el.tagName.toLowerCase() !== 'i') return;
          el.setAttribute('data-lucide', expression);
          lucide.createIcons({
            attrs: { class: el.getAttribute('class') },
            nameAttr: 'data-lucide',
            root: el.parentElement,
          });
        });

        Alpine.directive('lucide-dynamic', (el, { expression }, { evaluate }) => {
          if (el.tagName.toLowerCase() !== 'i') return;
          el.setAttribute('data-lucide', evaluate(expression));
          lucide.createIcons({
            attrs: { class: el.getAttribute('class') },
            nameAttr: 'data-lucide',
            root: el.parentElement,
          });
        });

        Alpine.store('app', {
          db: null,
          detail: { tab: 'info' },
          refuelHistory: [],
          getEfficiencyHistory() {
            return this.refuelHistory;
          },
        });

        Alpine.data('app', () => ({
          router: { current: 'onboarding' },

          get db() {
            return Alpine.store('app').db;
          },
          set db(val) {
            Alpine.store('app').db = val;
          },

          modal: { active: false, type: null },

          get detail() {
            return Alpine.store('app').detail;
          },
          set detail(val) {
            Alpine.store('app').detail = val;
          },

          forms: {
            car: {
              number: '',
              maker: '',
              model: '',
              year: '',
              fuelType: '휘발유',
              totalDistance: '',
            },
            record: {},
            maintenanceTimer: {
              title: '',
              mileageIntervalKm: '',
              timeIntervalDays: '',
              repeat: false,
            },
          },

          autocomplete: { open: false },
          filters: { dateStart: '', dateEnd: '', type: 'all', search: '' },
          recordPage: {
            items: [],
            cursor: null,
            nextCursor: null,
            hasPrev: false,
            hasNext: false,
            page: 1,
            limit: 20,
            loading: false,
          },
          recordPageCursors: [null],
          recordPageCursorIndex: 0,
          placeCounter: [],
          maintenanceTimers: [],
          refuelStats: { monthly: { current: 0, diff: 0 }, history: [] },
          toasts: [],
          backend: new DexieClxBackend(),
          clxClient: null,
          clxDocumentsChangedUnsubscribe: null,
          clxSyncCompleteUnsubscribe: null,
          remoteChanges: {
            carsChanged: false,
            changedRecordCarIds: new Set(),
            changedMaintenanceTimerCarIds: new Set(),
            unknownRecordChanges: false,
            unknownMaintenanceTimerChanges: false,
          },
          remoteChangesDrain: Promise.resolve(),
          isStartingDb: false,

          init() {
            this.db = null;
            this.maintenanceTimers = [];
            Alpine.store('app').refuelHistory = [];
          },

          supportsViewTransition() {
            return (
              typeof document.startViewTransition === 'function' &&
              !window.matchMedia('(prefers-reduced-motion: reduce)').matches
            );
          },

          async runViewTransition(update) {
            if (!this.supportsViewTransition()) {
              return await update();
            }

            const transition = document.startViewTransition(async () => {
              await update();
              await Alpine.nextTick();
            });

            await (transition.updateCallbackDone || transition.finished).catch(() => {});
          },

          get activeCar() {
            return this.db?.cars.find(c => c.id === this.detail.carId) || null;
          },

          get filteredRecords() {
            return this.recordPage.items;
          },

          get placeSuggestions() {
            return this.placeCounter.map(place => place.name);
          },

          get filteredPlaces() {
            const q = (this.forms.record.place || '').toLowerCase();
            return this.placeSuggestions.filter(p => p.toLowerCase().includes(q));
          },

          get maintenanceTimerCards() {
            const nowTimestamp = Date.now();
            const currentOdometerKm = Number(this.activeCar?.totalDistance) || 0;

            return this.maintenanceTimers
              .map(timer => this.buildMaintenanceTimerCard(timer, nowTimestamp, currentOdometerKm))
              .filter(Boolean)
              .sort((a, b) => {
                if (a.priority !== b.priority) return a.priority - b.priority;
                return String(a.title || '').localeCompare(String(b.title || ''), 'ko');
              });
          },

          getRemainingMileageLabel(remainingKm) {
            const normalizedRemainingKm = Number(remainingKm) || 0;

            if (normalizedRemainingKm >= 0) {
              return `${this.formatNumber(Math.max(0, Math.ceil(normalizedRemainingKm)))}km 남음`;
            }

            return `${this.formatNumber(Math.max(1, Math.ceil(Math.abs(normalizedRemainingKm))))}km 초과`;
          },

          getRemainingTimeLabel(remainingDays) {
            const normalizedRemainingDays = Number(remainingDays) || 0;

            if (normalizedRemainingDays >= 0) {
              return `${this.formatNumber(Math.max(0, Math.ceil(normalizedRemainingDays)))}일 남음`;
            }

            return `${this.formatNumber(Math.max(1, Math.ceil(Math.abs(normalizedRemainingDays))))}일 초과`;
          },

          getMaintenanceTimerConditionLabel(timer, primaryConditionKind, conditionCount) {
            const mileageIntervalKm = Number(timer?.mileageIntervalKm);
            const timeIntervalDays = Number(timer?.timeIntervalDays);
            const mileageLabel =
              Number.isFinite(mileageIntervalKm) && mileageIntervalKm > 0
                ? `${this.formatNumber(Math.round(mileageIntervalKm))}km`
                : '';
            const timeLabel =
              Number.isFinite(timeIntervalDays) && timeIntervalDays > 0
                ? `${this.formatNumber(Math.round(timeIntervalDays))}일`
                : '';

            if (conditionCount > 1 && mileageLabel && timeLabel) {
              const primaryLabel =
                primaryConditionKind === 'mileage' ? '마일리지 우선' : '시간 우선';
              return `${mileageLabel} / ${timeLabel} (${primaryLabel})`;
            }

            if (mileageLabel) return `${mileageLabel} 주기`;
            if (timeLabel) return `${timeLabel} 주기`;
            return '주기 미설정';
          },

          buildMaintenanceTimerCard(timer, nowTimestamp = Date.now(), currentOdometerKm = 0) {
            if (!timer) return null;

            const conditions = [];
            const mileageIntervalKm = Number(timer.mileageIntervalKm);
            const baseOdometerKm = Number(timer.baseOdometerKm) || 0;

            if (Number.isFinite(mileageIntervalKm) && mileageIntervalKm > 0) {
              const elapsedKm = Math.max(0, currentOdometerKm - baseOdometerKm);
              const remainingKm = mileageIntervalKm - elapsedKm;
              conditions.push({
                kind: 'mileage',
                progressRatio: elapsedKm / mileageIntervalKm,
                remainingRatio: remainingKm / mileageIntervalKm,
                remainingValue: remainingKm,
                remainingLabel: this.getRemainingMileageLabel(remainingKm),
              });
            }

            const timeIntervalDays = Number(timer.timeIntervalDays);
            const baseStartedTimestamp = Date.parse(
              String(timer.baseStartedAt || timer.createdAt || '')
            );
            const safeBaseStartedTimestamp = Number.isFinite(baseStartedTimestamp)
              ? baseStartedTimestamp
              : nowTimestamp;

            if (Number.isFinite(timeIntervalDays) && timeIntervalDays > 0) {
              const elapsedDays = Math.max(
                0,
                (nowTimestamp - safeBaseStartedTimestamp) / DAY_IN_MS
              );
              const remainingDays = timeIntervalDays - elapsedDays;
              conditions.push({
                kind: 'time',
                progressRatio: elapsedDays / timeIntervalDays,
                remainingRatio: remainingDays / timeIntervalDays,
                remainingValue: remainingDays,
                remainingLabel: this.getRemainingTimeLabel(remainingDays),
              });
            }

            if (!conditions.length) return null;

            const primaryCondition = conditions.reduce((selectedCondition, condition) => {
              if (!selectedCondition) return condition;
              return condition.remainingRatio < selectedCondition.remainingRatio
                ? condition
                : selectedCondition;
            }, null);

            if (!primaryCondition) return null;

            return {
              id: String(timer.id || ''),
              title: String(timer.title || '').trim() || '정비 타이머',
              repeat: Boolean(timer.repeat),
              progressPercent: Math.min(
                100,
                Math.max(0, Math.round((Number(primaryCondition.progressRatio) || 0) * 100))
              ),
              isOverdue: Number(primaryCondition.remainingValue) < 0,
              remainingLabel: primaryCondition.remainingLabel,
              conditionLabel: this.getMaintenanceTimerConditionLabel(
                timer,
                primaryCondition.kind,
                conditions.length
              ),
              priority: Number(primaryCondition.remainingRatio),
            };
          },

          isRecordTab(tab = this.detail.tab) {
            return ['refuel', 'maintenance', 'etc'].includes(tab);
          },

          buildRecordFilters() {
            return {
              dateStart: this.filters.dateStart,
              dateEnd: this.filters.dateEnd,
              maintenanceType: this.filters.type,
              search: this.filters.search,
            };
          },

          resetRecordPageState() {
            this.recordPageCursors = [null];
            this.recordPageCursorIndex = 0;
            this.recordPage = {
              ...this.recordPage,
              items: [],
              cursor: null,
              nextCursor: null,
              hasPrev: false,
              hasNext: false,
              page: 1,
              loading: false,
            };
          },

          getRecordsPageLabel() {
            if (
              !this.filteredRecords.length &&
              !this.recordPage.hasPrev &&
              !this.recordPage.hasNext
            ) {
              return '0 페이지';
            }

            return `${this.recordPage.page} 페이지`;
          },

          getCurrentRecordCursor() {
            return this.recordPageCursors[this.recordPageCursorIndex] ?? null;
          },

          async loadRecordsPage(cursor = null) {
            if (!this.backend.isReady() || !this.detail.carId || !this.isRecordTab()) {
              this.resetRecordPageState();
              return;
            }

            this.recordPage.loading = true;
            try {
              const page = await this.backend.readRecordsPage({
                carId: this.detail.carId,
                tab: this.detail.tab,
                filters: this.buildRecordFilters(),
                cursor,
                limit: this.recordPage.limit,
              });

              this.recordPage = {
                ...this.recordPage,
                ...page,
                hasPrev: this.recordPageCursorIndex > 0,
                page: this.recordPageCursorIndex + 1,
                loading: false,
              };
            } catch (error) {
              console.error(error);
              this.recordPage.loading = false;
            }
          },

          async goToPrevRecordsPage() {
            if (!this.recordPage.hasPrev) return;

            this.recordPageCursorIndex = Math.max(0, this.recordPageCursorIndex - 1);
            await this.loadRecordsPage(this.getCurrentRecordCursor());
          },

          async goToNextRecordsPage() {
            if (!this.recordPage.hasNext || this.recordPage.nextCursor === null) return;

            this.recordPageCursors = this.recordPageCursors.slice(
              0,
              this.recordPageCursorIndex + 1
            );
            this.recordPageCursors.push(this.recordPage.nextCursor);
            this.recordPageCursorIndex += 1;
            await this.loadRecordsPage(this.recordPage.nextCursor);
          },

          async handleFiltersChanged() {
            if (!this.isRecordTab() || !this.detail.carId) return;

            this.recordPageCursors = [null];
            this.recordPageCursorIndex = 0;
            await this.loadRecordsPage(null);
          },

          async refreshPlaceCounter() {
            if (!this.backend.isReady() || !this.detail.carId) {
              this.placeCounter = [];
              return;
            }

            this.placeCounter = await this.backend.readPlaceCounter(this.detail.carId);
          },

          async refreshRefuelStats() {
            if (!this.backend.isReady() || !this.detail.carId) {
              this.refuelStats = { monthly: { current: 0, diff: 0 }, history: [] };
              Alpine.store('app').refuelHistory = [];
              return;
            }

            const [monthly, history] = await Promise.all([
              this.backend.readMonthlyRefuelCost(this.detail.carId),
              this.backend.readEfficiencyHistory(this.detail.carId, 20),
            ]);

            this.refuelStats = { monthly, history };
            Alpine.store('app').refuelHistory = history;
          },

          async refreshMaintenanceTimers() {
            if (!this.backend.isReady() || !this.detail.carId) {
              this.maintenanceTimers = [];
              return;
            }

            this.maintenanceTimers = await this.backend.readMaintenanceTimers(this.detail.carId);
          },

          async refreshActiveCarData({ resetPage = true } = {}) {
            if (!this.backend.isReady() || !this.detail.carId) {
              this.resetRecordPageState();
              this.placeCounter = [];
              this.maintenanceTimers = [];
              this.refuelStats = { monthly: { current: 0, diff: 0 }, history: [] };
              Alpine.store('app').refuelHistory = [];
              return;
            }

            await Promise.all([
              this.refreshPlaceCounter(),
              this.refreshRefuelStats(),
              this.refreshMaintenanceTimers(),
            ]);

            if (this.isRecordTab()) {
              if (resetPage) {
                this.recordPageCursors = [null];
                this.recordPageCursorIndex = 0;
              }

              await this.loadRecordsPage(this.getCurrentRecordCursor());
            }
          },

          getEfficiency(record, _index) {
            if (this.detail.tab !== 'refuel' || !record?.id) return null;

            const targetRecordId = String(record.id);
            const entry = calculateRefuelEfficiencyEntries(this.filteredRecords).find(
              item => item.recordId === targetRecordId
            );

            if (!entry) return null;
            return { dist: entry.dist, eff: entry.eff };
          },

          getMonthlyRefuelCost() {
            return this.refuelStats.monthly;
          },

          getEfficiencyHistory() {
            return Alpine.store('app').getEfficiencyHistory();
          },

          async reloadCars() {
            if (!this.backend.isReady()) {
              this.db = null;
              this.maintenanceTimers = [];
              return;
            }

            const cars = await this.backend.readCars();
            this.db = { config: { type: 'clxdb' }, cars, records: [] };

            if (this.detail.carId && !cars.some(car => car.id === this.detail.carId)) {
              this.detail = { tab: 'info' };
              this.resetRecordPageState();
              this.placeCounter = [];
              this.maintenanceTimers = [];
              this.refuelStats = { monthly: { current: 0, diff: 0 }, history: [] };
              Alpine.store('app').refuelHistory = [];
              if (this.router.current === 'car-detail') {
                this.router.current = 'car-list';
              }
            }
          },

          resetRemoteChanges() {
            this.remoteChanges.carsChanged = false;
            this.remoteChanges.changedRecordCarIds.clear();
            this.remoteChanges.changedMaintenanceTimerCarIds.clear();
            this.remoteChanges.unknownRecordChanges = false;
            this.remoteChanges.unknownMaintenanceTimerChanges = false;
          },

          queueRemoteChangeTask(task) {
            this.remoteChangesDrain = this.remoteChangesDrain
              .then(() => task())
              .catch(error => {
                console.error(error);
              });
          },

          async handleRemoteDocumentsChanged(documents) {
            if (!Array.isArray(documents) || documents.length === 0) return;

            const unresolvedRecordIds = [];

            for (const document of documents) {
              if (document.id.startsWith('car:')) {
                this.remoteChanges.carsChanged = true;
                continue;
              }

              if (this.backend.isMaintenanceTimerDocumentId(document.id)) {
                const carId =
                  (document.data?.carId && String(document.data.carId)) ||
                  this.backend.getCarIdFromMaintenanceTimerDocumentId(document.id);

                if (carId) {
                  this.remoteChanges.changedMaintenanceTimerCarIds.add(carId);
                } else {
                  this.remoteChanges.unknownMaintenanceTimerChanges = true;
                }
                continue;
              }

              if (!document.id.startsWith('record:')) {
                continue;
              }

              const carId = document.data?.carId ? String(document.data.carId) : null;
              if (carId) {
                this.remoteChanges.changedRecordCarIds.add(carId);
              } else {
                unresolvedRecordIds.push(document.id);
              }
            }

            if (!unresolvedRecordIds.length || !this.backend.isReady()) {
              return;
            }

            const carIdsByDocumentId = await this.backend.readRecordCarIds(unresolvedRecordIds);
            for (const id of unresolvedRecordIds) {
              const carId = carIdsByDocumentId[id];
              if (carId) {
                this.remoteChanges.changedRecordCarIds.add(carId);
              } else {
                this.remoteChanges.unknownRecordChanges = true;
              }
            }
          },

          async flushRemoteChanges() {
            const hasChanges =
              this.remoteChanges.carsChanged ||
              this.remoteChanges.unknownRecordChanges ||
              this.remoteChanges.unknownMaintenanceTimerChanges ||
              this.remoteChanges.changedRecordCarIds.size > 0 ||
              this.remoteChanges.changedMaintenanceTimerCarIds.size > 0;

            if (!hasChanges) return;

            if (!this.backend.isReady()) {
              this.resetRemoteChanges();
              return;
            }

            if (this.remoteChanges.carsChanged) {
              await this.reloadCars();
            }

            const activeCarId = this.detail.carId;
            const shouldRefreshActiveCar =
              Boolean(activeCarId) &&
              (this.remoteChanges.unknownRecordChanges ||
                this.remoteChanges.unknownMaintenanceTimerChanges ||
                this.remoteChanges.changedRecordCarIds.has(activeCarId) ||
                this.remoteChanges.changedMaintenanceTimerCarIds.has(activeCarId));

            if (shouldRefreshActiveCar) {
              await Promise.all([
                this.refreshPlaceCounter(),
                this.refreshRefuelStats(),
                this.refreshMaintenanceTimers(),
              ]);

              if (this.isRecordTab()) {
                this.recordPageCursors = [null];
                this.recordPageCursorIndex = 0;
                await this.loadRecordsPage(null);
              }
            }

            this.resetRemoteChanges();
          },

          async triggerSync() {
            if (!this.clxClient) return;
            try {
              await this.clxClient.sync();
            } catch (error) {
              console.error(error);
            }
          },

          disconnectClient() {
            this.clxDocumentsChangedUnsubscribe?.();
            this.clxDocumentsChangedUnsubscribe = null;
            this.clxSyncCompleteUnsubscribe?.();
            this.clxSyncCompleteUnsubscribe = null;
            this.clxClient?.destroy();
            this.clxClient = null;
            this.backend.close();
            this.resetRemoteChanges();
            this.remoteChangesDrain = Promise.resolve();
          },

          async startDatabase() {
            if (this.isStartingDb) return;

            this.isStartingDb = true;
            try {
              this.disconnectClient();

              const client = await clxdb.startClxDBWithUI({
                database: this.backend,
                ui: {
                  theme: 'dark',
                  i18n: { locale: 'ko' },
                  style: {
                    palette: { primaryColor: '#6366f1', defaultColor: '#202020' },
                    fontFamily: 'var(--font-sans)',
                  },
                  syncIndicator: true,
                },
              });

              if (!client) {
                return;
              }

              this.clxClient = client;
              this.clxDocumentsChangedUnsubscribe = client.on('documentsChanged', documents => {
                this.queueRemoteChangeTask(() => this.handleRemoteDocumentsChanged(documents));
              });
              this.clxSyncCompleteUnsubscribe = client.on('syncComplete', () => {
                this.queueRemoteChangeTask(() => this.flushRemoteChanges());
              });

              await this.reloadCars();
              this.resetRecordPageState();
              this.placeCounter = [];
              this.maintenanceTimers = [];
              await this.refreshRefuelStats();
              await this.runViewTransition(() => {
                this.router.current = 'car-list';
              });
              this.showToast('데이터베이스 연결됨', 'success');
            } catch (error) {
              console.error(error);
              this.showToast('데이터베이스 연결 실패', 'error');
            } finally {
              this.isStartingDb = false;
            }
          },

          async switchTab(tab) {
            if (this.detail.tab === tab) return;

            await this.runViewTransition(() => {
              this.detail.tab = tab;
            });

            if (!this.detail.carId) {
              this.resetRecordPageState();
              return;
            }

            if (this.isRecordTab(tab)) {
              this.recordPageCursors = [null];
              this.recordPageCursorIndex = 0;
              await this.loadRecordsPage(null);
              await this.refreshPlaceCounter();
            } else {
              this.resetRecordPageState();
            }

            if (tab === 'refuel') {
              await this.refreshRefuelStats();
            }

            if (tab === 'maintenance') {
              await this.refreshMaintenanceTimers();
            }
          },

          openModal(t) {
            this.modal.type = t;
            this.modal.active = true;

            if (t === 'add-car') {
              this.forms.car = {
                number: '',
                maker: '',
                model: '',
                year: 2024,
                fuelType: '휘발유',
                totalDistance: '',
              };
            }

            if (t === 'add-record') {
              const today = new Date().toISOString().split('T')[0];
              this.forms.record = {
                date: today,
                odometer: this.activeCar?.totalDistance || 0,
                amount: '',
                place: '',
                subType:
                  this.detail.tab === 'refuel'
                    ? 'full'
                    : this.detail.tab === 'maintenance'
                      ? 'maintenance'
                      : '',
                unitPrice: '',
                volume: '',
                fuelGauge: '',
                prevRefuelUnknown: false,
                item: '',
                memo: '',
              };
              this.autocomplete.open = false;
            }

            if (t === 'add-maintenance-timer') {
              this.forms.maintenanceTimer = {
                title: '',
                mileageIntervalKm: '',
                timeIntervalDays: '',
                repeat: false,
              };
            }
          },

          closeModal() {
            this.modal.active = false;
            setTimeout(() => (this.modal.type = null), 200);
          },

          async submitAddCar() {
            if (!this.backend.isReady()) return;

            const c = {
              id: crypto.randomUUID(),
              ...this.forms.car,
              totalDistance: Number(this.forms.car.totalDistance) || 0,
              createdAt: new Date().toISOString(),
            };
            await this.backend.stageUpsertDocument(`car:${c.id}`, c);
            await this.reloadCars();
            void this.triggerSync();
            this.closeModal();
            this.showToast('차량 추가됨', 'success');
          },

          async submitAddRecord() {
            if (!this.backend.isReady()) return;

            const r = this.forms.record;
            const rec = {
              id: crypto.randomUUID(),
              carId: this.detail.carId,
              type: this.detail.tab,
              date: r.date,
              amount: Number(r.amount) || 0,
              odometer: Number(r.odometer) || 0,
              place: r.place,
              subType: r.subType,
              unitPrice: Number(r.unitPrice) || null,
              volume: Number(r.volume) || null,
              fuelGauge: Number(r.fuelGauge) || null,
              prevRefuelUnknown: Boolean(r.prevRefuelUnknown),
              item: r.item,
              memo: r.memo,
              createdAt: new Date().toISOString(),
            };

            await this.backend.stageUpsertDocument(`record:${rec.id}`, rec);

            const car = this.activeCar;
            if (car && rec.odometer > car.totalDistance) {
              await this.backend.stageUpsertDocument(`car:${car.id}`, {
                ...car,
                totalDistance: rec.odometer,
              });
            }

            await this.reloadCars();
            await this.refreshActiveCarData({ resetPage: true });
            void this.triggerSync();
            this.closeModal();
            this.showToast('기록 추가됨', 'success');
          },

          async submitAddMaintenanceTimer() {
            if (!this.backend.isReady() || !this.detail.carId || !this.activeCar) return;

            const title = String(this.forms.maintenanceTimer.title || '').trim();
            const mileageIntervalKm = Number(this.forms.maintenanceTimer.mileageIntervalKm);
            const timeIntervalDays = Number(this.forms.maintenanceTimer.timeIntervalDays);
            const normalizedMileageIntervalKm =
              Number.isFinite(mileageIntervalKm) && mileageIntervalKm > 0
                ? Math.round(mileageIntervalKm)
                : null;
            const normalizedTimeIntervalDays =
              Number.isFinite(timeIntervalDays) && timeIntervalDays > 0
                ? Math.round(timeIntervalDays)
                : null;

            if (!title) {
              this.showToast('타이머 제목을 입력하세요.', 'error');
              return;
            }

            if (!normalizedMileageIntervalKm && !normalizedTimeIntervalDays) {
              this.showToast('마일리지 또는 시간 조건을 입력하세요.', 'error');
              return;
            }

            const nowIso = new Date().toISOString();
            const nextTimers = [
              {
                id: crypto.randomUUID(),
                title,
                mileageIntervalKm: normalizedMileageIntervalKm,
                timeIntervalDays: normalizedTimeIntervalDays,
                repeat: Boolean(this.forms.maintenanceTimer.repeat),
                baseOdometerKm: Number(this.activeCar.totalDistance) || 0,
                baseStartedAt: nowIso,
                createdAt: nowIso,
              },
              ...this.maintenanceTimers,
            ];

            await this.backend.stageMaintenanceTimers(this.detail.carId, nextTimers);
            await this.refreshMaintenanceTimers();
            void this.triggerSync();
            this.closeModal();
            this.showToast('정비 타이머 추가됨', 'success');
          },

          async completeMaintenanceTimer(timerId) {
            if (!this.backend.isReady() || !this.detail.carId) return;

            const normalizedTimerId = String(timerId || '');
            if (!normalizedTimerId) return;

            const targetTimer = this.maintenanceTimers.find(
              timer => String(timer.id || '') === normalizedTimerId
            );
            if (!targetTimer) return;

            const currentOdometerKm = Number(this.activeCar?.totalDistance) || 0;
            const nowIso = new Date().toISOString();

            const nextTimers = targetTimer.repeat
              ? this.maintenanceTimers.map(timer =>
                  String(timer.id || '') === normalizedTimerId
                    ? {
                        ...timer,
                        baseOdometerKm: currentOdometerKm,
                        baseStartedAt: nowIso,
                      }
                    : timer
                )
              : this.maintenanceTimers.filter(
                  timer => String(timer.id || '') !== normalizedTimerId
                );

            await this.backend.stageMaintenanceTimers(this.detail.carId, nextTimers);
            await this.refreshMaintenanceTimers();
            void this.triggerSync();
            this.showToast(
              targetTimer.repeat
                ? '정비 타이머가 다음 주기로 리셋되었습니다.'
                : '정비 타이머 완료됨',
              'success'
            );
          },

          async deleteMaintenanceTimer(timerId) {
            if (!this.backend.isReady() || !this.detail.carId) return;

            const normalizedTimerId = String(timerId || '');
            if (!normalizedTimerId) return;

            if (!confirm('정말로 이 정비 타이머를 삭제하시겠습니까?')) {
              return;
            }

            const nextTimers = this.maintenanceTimers.filter(
              timer => String(timer.id || '') !== normalizedTimerId
            );

            if (nextTimers.length === this.maintenanceTimers.length) return;

            await this.backend.stageMaintenanceTimers(this.detail.carId, nextTimers);
            await this.refreshMaintenanceTimers();
            void this.triggerSync();
            this.showToast('정비 타이머가 삭제되었습니다.', 'success');
          },

          async deleteRecord(id) {
            if (!this.backend.isReady()) return;

            if (confirm('정말로 이 기록을 삭제하시겠습니까?')) {
              await this.backend.stageDeleteDocument(`record:${id}`);
              await this.refreshActiveCarData({ resetPage: false });
              void this.triggerSync();
              this.showToast('기록이 삭제되었습니다.', 'success');
            }
          },

          async goToCarList() {
            await this.runViewTransition(() => {
              this.router.current = 'car-list';
              this.detail.carId = null;
            });

            this.maintenanceTimers = [];
          },

          async selectCar(id) {
            await this.runViewTransition(() => {
              this.detail.carId = id;
              this.detail.tab = 'info';
              this.router.current = 'car-detail';
              this.resetRecordPageState();
            });

            await Promise.all([
              this.refreshPlaceCounter(),
              this.refreshRefuelStats(),
              this.refreshMaintenanceTimers(),
            ]);
          },

          toggleEditInfo() {
            if (this.detail.isEditing) {
              this.detail.isEditing = false;
            } else {
              this.detail.carInfoEditBuffer = { ...this.activeCar };
              this.detail.isEditing = true;
            }
          },

          async saveCarInfo() {
            if (!this.backend.isReady() || !this.activeCar) return;

            await this.backend.stageUpsertDocument(`car:${this.detail.carId}`, {
              ...this.activeCar,
              ...this.detail.carInfoEditBuffer,
              year: Number(this.detail.carInfoEditBuffer.year),
            });

            await this.reloadCars();
            void this.triggerSync();
            this.detail.isEditing = false;
            this.showToast('정보 저장됨', 'success');
          },

          calculateVolume() {
            if (
              this.detail.tab === 'refuel' &&
              this.forms.record.amount &&
              this.forms.record.unitPrice
            ) {
              this.forms.record.volume = (
                this.forms.record.amount / this.forms.record.unitPrice
              ).toFixed(2);
            }
          },

          getAddButtonText() {
            return (
              {
                refuel: '주유 추가',
                maintenance: '정비 추가',
                etc: '지출 추가',
              }[this.detail.tab] || '추가'
            );
          },

          getModalTitle() {
            return (
              {
                'add-car': '차량 추가',
                'add-record': '새로운 기록',
                'add-maintenance-timer': '정비 타이머 추가',
              }[this.modal.type] || '설정'
            );
          },

          getCarInfoValue(label) {
            const c = this.activeCar;
            if (!c) return '-';
            const m = {
              '차량번호': c.number,
              '제조사': c.maker,
              '차종': c.model,
              '등급': c.grade,
              '연식': c.year + '년',
              '연료': c.fuelType,
              '배기량': c.displacement ? this.formatNumber(c.displacement) + 'cc' : '-',
              '누적 주행거리': this.formatDistance(c.totalDistance),
            };
            return m[label];
          },

          getSubTypeLabel(r) {
            const m = {
              full: '가득',
              partial: '부분',
              maintenance: '정비',
              inspection: '점검',
            };
            return m[r.subType] || (this.detail.tab === 'etc' ? '지출' : '-');
          },

          getRecordLabel(r) {
            return r.volume ? `${r.volume}L` : r.item || r.title || '내역 없음';
          },

          formatDistance(k) {
            return new Intl.NumberFormat('ko-KR').format(k) + 'km';
          },

          formatNumber(n) {
            return new Intl.NumberFormat('ko-KR').format(n);
          },

          showToast(msg, type = 'info') {
            const id = Date.now();
            this.toasts.push({ id, message: msg, type, visible: true });
            setTimeout(() => (this.toasts.find(t => t.id === id).visible = false), 3000);
            setTimeout(() => (this.toasts = this.toasts.filter(t => t.id !== id)), 3500);
          },

          async exportDB() {
            if (!this.backend.isReady()) return;

            try {
              const snapshot = await this.backend.loadSnapshot();
              const a = document.createElement('a');
              a.href =
                'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(snapshot));
              a.download = `vehlog_backup_${new Date().toISOString().slice(0, 10)}.json`;
              document.body.appendChild(a);
              a.click();
              a.remove();
            } catch (error) {
              console.error(error);
              this.showToast('백업 실패', 'error');
            }
          },

          triggerImport() {
            document.getElementById('fileInput').click();
          },

          handleFileImport(e) {
            const f = e.target.files[0];
            if (!f) return;
            const r = new FileReader();
            r.onload = async ev => {
              try {
                if (!this.backend.isReady()) {
                  this.showToast('먼저 데이터베이스를 시작하세요.', 'error');
                  return;
                }

                await this.backend.importSnapshot(JSON.parse(ev.target.result));
                this.detail = { tab: 'info' };
                this.resetRecordPageState();
                this.placeCounter = [];
                this.maintenanceTimers = [];
                this.refuelStats = { monthly: { current: 0, diff: 0 }, history: [] };
                Alpine.store('app').refuelHistory = [];
                await this.reloadCars();
                void this.triggerSync();
                this.router.current = 'car-list';
                this.showToast('복원됨', 'success');
              } catch (e) {
                this.showToast('오류', 'error');
              }
            };
            r.readAsText(f);
            e.target.value = '';
          },

          closeDatabase() {
            this.disconnectClient();
            this.db = null;
            this.detail = { tab: 'info' };
            this.resetRecordPageState();
            this.placeCounter = [];
            this.maintenanceTimers = [];
            this.refuelStats = { monthly: { current: 0, diff: 0 }, history: [] };
            Alpine.store('app').refuelHistory = [];
            this.resetRemoteChanges();
            this.router.current = 'onboarding';
          },
        }));

        Alpine.data('chart', () => ({
          hover: false,
          hoverX: 0,
          hoverIndex: -1,
          points: [],

          initChart() {
            this.$watch('$store.app.detail.tab', () => this.calcPoints());
            this.$watch('$store.app.db', () => this.calcPoints());
            this.$watch('$store.app.refuelHistory', () => this.calcPoints());
            this.calcPoints();
          },

          calcPoints() {
            const history = this.$store.app.getEfficiencyHistory();
            if (history.length < 2) {
              this.points = [];
              return;
            }
            const maxVal = Math.max(...history.map(p => p.val));
            const minVal = Math.min(...history.map(p => p.val));
            const range = maxVal - minVal || 1;
            // Padding: top 20%, bottom 20%
            const yBase = 80;
            const yScale = 60 / range;

            this.points = history.map((pt, i) => ({
              x: (i / (history.length - 1)) * 100,
              y: 80 - (pt.val - minVal) * yScale,
              val: pt.val,
              date: pt.date,
            }));
          },

          getPath() {
            if (this.points.length < 2) return '';
            return this.points.map((p, i) => (i === 0 ? 'M' : 'L') + `${p.x},${p.y}`).join(' ');
          },

          getAreaPath() {
            if (this.points.length < 2) return '';
            const path = this.getPath();
            return `${path} L 100,100 L 0,100 Z`;
          },

          handleMouseMove(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 100;

            // Find closest point
            let minDist = 1000;
            this.points.forEach((p, i) => {
              const dist = Math.abs(p.x - x);
              if (dist < minDist) {
                minDist = dist;
                this.hoverIndex = i;
              }
            });

            this.hoverX = this.points[this.hoverIndex].x;
            this.hover = true;
          },
        }));
      });
    </script>
  </body>
</html>
